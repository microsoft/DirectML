// This file is generated by GenerateHelpers.ps1. Do not edit manually or your changes will be lost!

// ====================================================================================================
// DIRECTML ENUMS
// ====================================================================================================

DML_TENSOR_DATA_TYPE ParseDmlTensorDataType(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_TENSOR_DATA_TYPE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_UNKNOWN") || !strcmp(valueString, "UNKNOWN")) { return DML_TENSOR_DATA_TYPE_UNKNOWN; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_FLOAT32") || !strcmp(valueString, "FLOAT32")) { return DML_TENSOR_DATA_TYPE_FLOAT32; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_FLOAT16") || !strcmp(valueString, "FLOAT16")) { return DML_TENSOR_DATA_TYPE_FLOAT16; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_UINT32") || !strcmp(valueString, "UINT32")) { return DML_TENSOR_DATA_TYPE_UINT32; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_UINT16") || !strcmp(valueString, "UINT16")) { return DML_TENSOR_DATA_TYPE_UINT16; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_UINT8") || !strcmp(valueString, "UINT8")) { return DML_TENSOR_DATA_TYPE_UINT8; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_INT32") || !strcmp(valueString, "INT32")) { return DML_TENSOR_DATA_TYPE_INT32; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_INT16") || !strcmp(valueString, "INT16")) { return DML_TENSOR_DATA_TYPE_INT16; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_INT8") || !strcmp(valueString, "INT8")) { return DML_TENSOR_DATA_TYPE_INT8; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_FLOAT64") || !strcmp(valueString, "FLOAT64")) { return DML_TENSOR_DATA_TYPE_FLOAT64; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_UINT64") || !strcmp(valueString, "UINT64")) { return DML_TENSOR_DATA_TYPE_UINT64; }
    if (!strcmp(valueString, "DML_TENSOR_DATA_TYPE_INT64") || !strcmp(valueString, "INT64")) { return DML_TENSOR_DATA_TYPE_INT64; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_TENSOR_DATA_TYPE.", valueString));
}

DML_TENSOR_DATA_TYPE ParseDmlTensorDataTypeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_TENSOR_DATA_TYPE defaultValue)
{
    return ParseFieldHelper<DML_TENSOR_DATA_TYPE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlTensorDataType(value); 
    });
}

DML_TENSOR_TYPE ParseDmlTensorType(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_TENSOR_TYPE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_TENSOR_TYPE_INVALID") || !strcmp(valueString, "INVALID")) { return DML_TENSOR_TYPE_INVALID; }
    if (!strcmp(valueString, "DML_TENSOR_TYPE_BUFFER") || !strcmp(valueString, "BUFFER")) { return DML_TENSOR_TYPE_BUFFER; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_TENSOR_TYPE.", valueString));
}

DML_TENSOR_TYPE ParseDmlTensorTypeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_TENSOR_TYPE defaultValue)
{
    return ParseFieldHelper<DML_TENSOR_TYPE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlTensorType(value); 
    });
}

DML_OPERATOR_TYPE ParseDmlOperatorType(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_OPERATOR_TYPE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_OPERATOR_INVALID") || !strcmp(valueString, "INVALID")) { return DML_OPERATOR_INVALID; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_IDENTITY") || !strcmp(valueString, "ELEMENT_WISE_IDENTITY")) { return DML_OPERATOR_ELEMENT_WISE_IDENTITY; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ABS") || !strcmp(valueString, "ELEMENT_WISE_ABS")) { return DML_OPERATOR_ELEMENT_WISE_ABS; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ACOS") || !strcmp(valueString, "ELEMENT_WISE_ACOS")) { return DML_OPERATOR_ELEMENT_WISE_ACOS; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ADD") || !strcmp(valueString, "ELEMENT_WISE_ADD")) { return DML_OPERATOR_ELEMENT_WISE_ADD; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ASIN") || !strcmp(valueString, "ELEMENT_WISE_ASIN")) { return DML_OPERATOR_ELEMENT_WISE_ASIN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ATAN") || !strcmp(valueString, "ELEMENT_WISE_ATAN")) { return DML_OPERATOR_ELEMENT_WISE_ATAN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_CEIL") || !strcmp(valueString, "ELEMENT_WISE_CEIL")) { return DML_OPERATOR_ELEMENT_WISE_CEIL; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_CLIP") || !strcmp(valueString, "ELEMENT_WISE_CLIP")) { return DML_OPERATOR_ELEMENT_WISE_CLIP; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_COS") || !strcmp(valueString, "ELEMENT_WISE_COS")) { return DML_OPERATOR_ELEMENT_WISE_COS; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_DIVIDE") || !strcmp(valueString, "ELEMENT_WISE_DIVIDE")) { return DML_OPERATOR_ELEMENT_WISE_DIVIDE; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_EXP") || !strcmp(valueString, "ELEMENT_WISE_EXP")) { return DML_OPERATOR_ELEMENT_WISE_EXP; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_FLOOR") || !strcmp(valueString, "ELEMENT_WISE_FLOOR")) { return DML_OPERATOR_ELEMENT_WISE_FLOOR; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOG") || !strcmp(valueString, "ELEMENT_WISE_LOG")) { return DML_OPERATOR_ELEMENT_WISE_LOG; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_AND") || !strcmp(valueString, "ELEMENT_WISE_LOGICAL_AND")) { return DML_OPERATOR_ELEMENT_WISE_LOGICAL_AND; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_EQUALS") || !strcmp(valueString, "ELEMENT_WISE_LOGICAL_EQUALS")) { return DML_OPERATOR_ELEMENT_WISE_LOGICAL_EQUALS; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN") || !strcmp(valueString, "ELEMENT_WISE_LOGICAL_GREATER_THAN")) { return DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN") || !strcmp(valueString, "ELEMENT_WISE_LOGICAL_LESS_THAN")) { return DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL") || !strcmp(valueString, "ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL")) { return DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL") || !strcmp(valueString, "ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL")) { return DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_NOT") || !strcmp(valueString, "ELEMENT_WISE_LOGICAL_NOT")) { return DML_OPERATOR_ELEMENT_WISE_LOGICAL_NOT; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_OR") || !strcmp(valueString, "ELEMENT_WISE_LOGICAL_OR")) { return DML_OPERATOR_ELEMENT_WISE_LOGICAL_OR; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_XOR") || !strcmp(valueString, "ELEMENT_WISE_LOGICAL_XOR")) { return DML_OPERATOR_ELEMENT_WISE_LOGICAL_XOR; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_MAX") || !strcmp(valueString, "ELEMENT_WISE_MAX")) { return DML_OPERATOR_ELEMENT_WISE_MAX; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_MEAN") || !strcmp(valueString, "ELEMENT_WISE_MEAN")) { return DML_OPERATOR_ELEMENT_WISE_MEAN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_MIN") || !strcmp(valueString, "ELEMENT_WISE_MIN")) { return DML_OPERATOR_ELEMENT_WISE_MIN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_MULTIPLY") || !strcmp(valueString, "ELEMENT_WISE_MULTIPLY")) { return DML_OPERATOR_ELEMENT_WISE_MULTIPLY; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_POW") || !strcmp(valueString, "ELEMENT_WISE_POW")) { return DML_OPERATOR_ELEMENT_WISE_POW; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_CONSTANT_POW") || !strcmp(valueString, "ELEMENT_WISE_CONSTANT_POW")) { return DML_OPERATOR_ELEMENT_WISE_CONSTANT_POW; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_RECIP") || !strcmp(valueString, "ELEMENT_WISE_RECIP")) { return DML_OPERATOR_ELEMENT_WISE_RECIP; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_SIN") || !strcmp(valueString, "ELEMENT_WISE_SIN")) { return DML_OPERATOR_ELEMENT_WISE_SIN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_SQRT") || !strcmp(valueString, "ELEMENT_WISE_SQRT")) { return DML_OPERATOR_ELEMENT_WISE_SQRT; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_SUBTRACT") || !strcmp(valueString, "ELEMENT_WISE_SUBTRACT")) { return DML_OPERATOR_ELEMENT_WISE_SUBTRACT; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_TAN") || !strcmp(valueString, "ELEMENT_WISE_TAN")) { return DML_OPERATOR_ELEMENT_WISE_TAN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_THRESHOLD") || !strcmp(valueString, "ELEMENT_WISE_THRESHOLD")) { return DML_OPERATOR_ELEMENT_WISE_THRESHOLD; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_QUANTIZE_LINEAR") || !strcmp(valueString, "ELEMENT_WISE_QUANTIZE_LINEAR")) { return DML_OPERATOR_ELEMENT_WISE_QUANTIZE_LINEAR; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_DEQUANTIZE_LINEAR") || !strcmp(valueString, "ELEMENT_WISE_DEQUANTIZE_LINEAR")) { return DML_OPERATOR_ELEMENT_WISE_DEQUANTIZE_LINEAR; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_ELU") || !strcmp(valueString, "ACTIVATION_ELU")) { return DML_OPERATOR_ACTIVATION_ELU; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_CELU") || !strcmp(valueString, "ACTIVATION_CELU")) { return DML_OPERATOR_ACTIVATION_CELU; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_HARDMAX") || !strcmp(valueString, "ACTIVATION_HARDMAX")) { return DML_OPERATOR_ACTIVATION_HARDMAX; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_HARDMAX1") || !strcmp(valueString, "ACTIVATION_HARDMAX1")) { return DML_OPERATOR_ACTIVATION_HARDMAX1; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_HARD_SIGMOID") || !strcmp(valueString, "ACTIVATION_HARD_SIGMOID")) { return DML_OPERATOR_ACTIVATION_HARD_SIGMOID; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_IDENTITY") || !strcmp(valueString, "ACTIVATION_IDENTITY")) { return DML_OPERATOR_ACTIVATION_IDENTITY; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_LEAKY_RELU") || !strcmp(valueString, "ACTIVATION_LEAKY_RELU")) { return DML_OPERATOR_ACTIVATION_LEAKY_RELU; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_LINEAR") || !strcmp(valueString, "ACTIVATION_LINEAR")) { return DML_OPERATOR_ACTIVATION_LINEAR; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_LOG_SOFTMAX") || !strcmp(valueString, "ACTIVATION_LOG_SOFTMAX")) { return DML_OPERATOR_ACTIVATION_LOG_SOFTMAX; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_LOG_SOFTMAX1") || !strcmp(valueString, "ACTIVATION_LOG_SOFTMAX1")) { return DML_OPERATOR_ACTIVATION_LOG_SOFTMAX1; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_PARAMETERIZED_RELU") || !strcmp(valueString, "ACTIVATION_PARAMETERIZED_RELU")) { return DML_OPERATOR_ACTIVATION_PARAMETERIZED_RELU; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_PARAMETRIC_SOFTPLUS") || !strcmp(valueString, "ACTIVATION_PARAMETRIC_SOFTPLUS")) { return DML_OPERATOR_ACTIVATION_PARAMETRIC_SOFTPLUS; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_RELU") || !strcmp(valueString, "ACTIVATION_RELU")) { return DML_OPERATOR_ACTIVATION_RELU; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_SCALED_ELU") || !strcmp(valueString, "ACTIVATION_SCALED_ELU")) { return DML_OPERATOR_ACTIVATION_SCALED_ELU; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_SCALED_TANH") || !strcmp(valueString, "ACTIVATION_SCALED_TANH")) { return DML_OPERATOR_ACTIVATION_SCALED_TANH; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_SIGMOID") || !strcmp(valueString, "ACTIVATION_SIGMOID")) { return DML_OPERATOR_ACTIVATION_SIGMOID; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_SOFTMAX") || !strcmp(valueString, "ACTIVATION_SOFTMAX")) { return DML_OPERATOR_ACTIVATION_SOFTMAX; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_SOFTMAX1") || !strcmp(valueString, "ACTIVATION_SOFTMAX1")) { return DML_OPERATOR_ACTIVATION_SOFTMAX1; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_SOFTPLUS") || !strcmp(valueString, "ACTIVATION_SOFTPLUS")) { return DML_OPERATOR_ACTIVATION_SOFTPLUS; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_SOFTSIGN") || !strcmp(valueString, "ACTIVATION_SOFTSIGN")) { return DML_OPERATOR_ACTIVATION_SOFTSIGN; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_TANH") || !strcmp(valueString, "ACTIVATION_TANH")) { return DML_OPERATOR_ACTIVATION_TANH; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_THRESHOLDED_RELU") || !strcmp(valueString, "ACTIVATION_THRESHOLDED_RELU")) { return DML_OPERATOR_ACTIVATION_THRESHOLDED_RELU; }
    if (!strcmp(valueString, "DML_OPERATOR_CONVOLUTION") || !strcmp(valueString, "CONVOLUTION")) { return DML_OPERATOR_CONVOLUTION; }
    if (!strcmp(valueString, "DML_OPERATOR_GEMM") || !strcmp(valueString, "GEMM")) { return DML_OPERATOR_GEMM; }
    if (!strcmp(valueString, "DML_OPERATOR_REDUCE") || !strcmp(valueString, "REDUCE")) { return DML_OPERATOR_REDUCE; }
    if (!strcmp(valueString, "DML_OPERATOR_AVERAGE_POOLING") || !strcmp(valueString, "AVERAGE_POOLING")) { return DML_OPERATOR_AVERAGE_POOLING; }
    if (!strcmp(valueString, "DML_OPERATOR_AVERAGE_POOLING1") || !strcmp(valueString, "AVERAGE_POOLING1")) { return DML_OPERATOR_AVERAGE_POOLING1; }
    if (!strcmp(valueString, "DML_OPERATOR_LP_POOLING") || !strcmp(valueString, "LP_POOLING")) { return DML_OPERATOR_LP_POOLING; }
    if (!strcmp(valueString, "DML_OPERATOR_LP_POOLING1") || !strcmp(valueString, "LP_POOLING1")) { return DML_OPERATOR_LP_POOLING1; }
    if (!strcmp(valueString, "DML_OPERATOR_MAX_POOLING") || !strcmp(valueString, "MAX_POOLING")) { return DML_OPERATOR_MAX_POOLING; }
    if (!strcmp(valueString, "DML_OPERATOR_ROI_POOLING") || !strcmp(valueString, "ROI_POOLING")) { return DML_OPERATOR_ROI_POOLING; }
    if (!strcmp(valueString, "DML_OPERATOR_SLICE") || !strcmp(valueString, "SLICE")) { return DML_OPERATOR_SLICE; }
    if (!strcmp(valueString, "DML_OPERATOR_CAST") || !strcmp(valueString, "CAST")) { return DML_OPERATOR_CAST; }
    if (!strcmp(valueString, "DML_OPERATOR_SPLIT") || !strcmp(valueString, "SPLIT")) { return DML_OPERATOR_SPLIT; }
    if (!strcmp(valueString, "DML_OPERATOR_JOIN") || !strcmp(valueString, "JOIN")) { return DML_OPERATOR_JOIN; }
    if (!strcmp(valueString, "DML_OPERATOR_PADDING") || !strcmp(valueString, "PADDING")) { return DML_OPERATOR_PADDING; }
    if (!strcmp(valueString, "DML_OPERATOR_PADDING1") || !strcmp(valueString, "PADDING1")) { return DML_OPERATOR_PADDING1; }
    if (!strcmp(valueString, "DML_OPERATOR_VALUE_SCALE_2D") || !strcmp(valueString, "VALUE_SCALE_2D")) { return DML_OPERATOR_VALUE_SCALE_2D; }
    if (!strcmp(valueString, "DML_OPERATOR_UPSAMPLE_2D") || !strcmp(valueString, "UPSAMPLE_2D")) { return DML_OPERATOR_UPSAMPLE_2D; }
    if (!strcmp(valueString, "DML_OPERATOR_GATHER") || !strcmp(valueString, "GATHER")) { return DML_OPERATOR_GATHER; }
    if (!strcmp(valueString, "DML_OPERATOR_SPACE_TO_DEPTH") || !strcmp(valueString, "SPACE_TO_DEPTH")) { return DML_OPERATOR_SPACE_TO_DEPTH; }
    if (!strcmp(valueString, "DML_OPERATOR_DEPTH_TO_SPACE") || !strcmp(valueString, "DEPTH_TO_SPACE")) { return DML_OPERATOR_DEPTH_TO_SPACE; }
    if (!strcmp(valueString, "DML_OPERATOR_TILE") || !strcmp(valueString, "TILE")) { return DML_OPERATOR_TILE; }
    if (!strcmp(valueString, "DML_OPERATOR_TOP_K") || !strcmp(valueString, "TOP_K")) { return DML_OPERATOR_TOP_K; }
    if (!strcmp(valueString, "DML_OPERATOR_BATCH_NORMALIZATION") || !strcmp(valueString, "BATCH_NORMALIZATION")) { return DML_OPERATOR_BATCH_NORMALIZATION; }
    if (!strcmp(valueString, "DML_OPERATOR_BATCH_NORMALIZATION_TRAINING") || !strcmp(valueString, "BATCH_NORMALIZATION_TRAINING")) { return DML_OPERATOR_BATCH_NORMALIZATION_TRAINING; }
    if (!strcmp(valueString, "DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION") || !strcmp(valueString, "MEAN_VARIANCE_NORMALIZATION")) { return DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION; }
    if (!strcmp(valueString, "DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION") || !strcmp(valueString, "LOCAL_RESPONSE_NORMALIZATION")) { return DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION; }
    if (!strcmp(valueString, "DML_OPERATOR_LP_NORMALIZATION") || !strcmp(valueString, "LP_NORMALIZATION")) { return DML_OPERATOR_LP_NORMALIZATION; }
    if (!strcmp(valueString, "DML_OPERATOR_RNN") || !strcmp(valueString, "RNN")) { return DML_OPERATOR_RNN; }
    if (!strcmp(valueString, "DML_OPERATOR_LSTM") || !strcmp(valueString, "LSTM")) { return DML_OPERATOR_LSTM; }
    if (!strcmp(valueString, "DML_OPERATOR_GRU") || !strcmp(valueString, "GRU")) { return DML_OPERATOR_GRU; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_SIGN") || !strcmp(valueString, "ELEMENT_WISE_SIGN")) { return DML_OPERATOR_ELEMENT_WISE_SIGN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_IS_NAN") || !strcmp(valueString, "ELEMENT_WISE_IS_NAN")) { return DML_OPERATOR_ELEMENT_WISE_IS_NAN; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ERF") || !strcmp(valueString, "ELEMENT_WISE_ERF")) { return DML_OPERATOR_ELEMENT_WISE_ERF; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_SINH") || !strcmp(valueString, "ELEMENT_WISE_SINH")) { return DML_OPERATOR_ELEMENT_WISE_SINH; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_COSH") || !strcmp(valueString, "ELEMENT_WISE_COSH")) { return DML_OPERATOR_ELEMENT_WISE_COSH; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_TANH") || !strcmp(valueString, "ELEMENT_WISE_TANH")) { return DML_OPERATOR_ELEMENT_WISE_TANH; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ASINH") || !strcmp(valueString, "ELEMENT_WISE_ASINH")) { return DML_OPERATOR_ELEMENT_WISE_ASINH; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ACOSH") || !strcmp(valueString, "ELEMENT_WISE_ACOSH")) { return DML_OPERATOR_ELEMENT_WISE_ACOSH; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ATANH") || !strcmp(valueString, "ELEMENT_WISE_ATANH")) { return DML_OPERATOR_ELEMENT_WISE_ATANH; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_IF") || !strcmp(valueString, "ELEMENT_WISE_IF")) { return DML_OPERATOR_ELEMENT_WISE_IF; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ADD1") || !strcmp(valueString, "ELEMENT_WISE_ADD1")) { return DML_OPERATOR_ELEMENT_WISE_ADD1; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_SHRINK") || !strcmp(valueString, "ACTIVATION_SHRINK")) { return DML_OPERATOR_ACTIVATION_SHRINK; }
    if (!strcmp(valueString, "DML_OPERATOR_MAX_POOLING1") || !strcmp(valueString, "MAX_POOLING1")) { return DML_OPERATOR_MAX_POOLING1; }
    if (!strcmp(valueString, "DML_OPERATOR_MAX_UNPOOLING") || !strcmp(valueString, "MAX_UNPOOLING")) { return DML_OPERATOR_MAX_UNPOOLING; }
    if (!strcmp(valueString, "DML_OPERATOR_DIAGONAL_MATRIX") || !strcmp(valueString, "DIAGONAL_MATRIX")) { return DML_OPERATOR_DIAGONAL_MATRIX; }
    if (!strcmp(valueString, "DML_OPERATOR_SCATTER") || !strcmp(valueString, "SCATTER")) { return DML_OPERATOR_SCATTER; }
    if (!strcmp(valueString, "DML_OPERATOR_ONE_HOT") || !strcmp(valueString, "ONE_HOT")) { return DML_OPERATOR_ONE_HOT; }
    if (!strcmp(valueString, "DML_OPERATOR_RESAMPLE") || !strcmp(valueString, "RESAMPLE")) { return DML_OPERATOR_RESAMPLE; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_LEFT") || !strcmp(valueString, "ELEMENT_WISE_BIT_SHIFT_LEFT")) { return DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_LEFT; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_RIGHT") || !strcmp(valueString, "ELEMENT_WISE_BIT_SHIFT_RIGHT")) { return DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_RIGHT; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ROUND") || !strcmp(valueString, "ELEMENT_WISE_ROUND")) { return DML_OPERATOR_ELEMENT_WISE_ROUND; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_IS_INFINITY") || !strcmp(valueString, "ELEMENT_WISE_IS_INFINITY")) { return DML_OPERATOR_ELEMENT_WISE_IS_INFINITY; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_MODULUS_TRUNCATE") || !strcmp(valueString, "ELEMENT_WISE_MODULUS_TRUNCATE")) { return DML_OPERATOR_ELEMENT_WISE_MODULUS_TRUNCATE; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_MODULUS_FLOOR") || !strcmp(valueString, "ELEMENT_WISE_MODULUS_FLOOR")) { return DML_OPERATOR_ELEMENT_WISE_MODULUS_FLOOR; }
    if (!strcmp(valueString, "DML_OPERATOR_FILL_VALUE_SEQUENCE") || !strcmp(valueString, "FILL_VALUE_SEQUENCE")) { return DML_OPERATOR_FILL_VALUE_SEQUENCE; }
    if (!strcmp(valueString, "DML_OPERATOR_FILL_VALUE_CONSTANT") || !strcmp(valueString, "FILL_VALUE_CONSTANT")) { return DML_OPERATOR_FILL_VALUE_CONSTANT; }
    if (!strcmp(valueString, "DML_OPERATOR_CUMULATIVE_SUMMATION") || !strcmp(valueString, "CUMULATIVE_SUMMATION")) { return DML_OPERATOR_CUMULATIVE_SUMMATION; }
    if (!strcmp(valueString, "DML_OPERATOR_REVERSE_SUBSEQUENCES") || !strcmp(valueString, "REVERSE_SUBSEQUENCES")) { return DML_OPERATOR_REVERSE_SUBSEQUENCES; }
    if (!strcmp(valueString, "DML_OPERATOR_GATHER_ELEMENTS") || !strcmp(valueString, "GATHER_ELEMENTS")) { return DML_OPERATOR_GATHER_ELEMENTS; }
    if (!strcmp(valueString, "DML_OPERATOR_GATHER_ND") || !strcmp(valueString, "GATHER_ND")) { return DML_OPERATOR_GATHER_ND; }
    if (!strcmp(valueString, "DML_OPERATOR_SCATTER_ND") || !strcmp(valueString, "SCATTER_ND")) { return DML_OPERATOR_SCATTER_ND; }
    if (!strcmp(valueString, "DML_OPERATOR_MAX_POOLING2") || !strcmp(valueString, "MAX_POOLING2")) { return DML_OPERATOR_MAX_POOLING2; }
    if (!strcmp(valueString, "DML_OPERATOR_SLICE1") || !strcmp(valueString, "SLICE1")) { return DML_OPERATOR_SLICE1; }
    if (!strcmp(valueString, "DML_OPERATOR_TOP_K1") || !strcmp(valueString, "TOP_K1")) { return DML_OPERATOR_TOP_K1; }
    if (!strcmp(valueString, "DML_OPERATOR_DEPTH_TO_SPACE1") || !strcmp(valueString, "DEPTH_TO_SPACE1")) { return DML_OPERATOR_DEPTH_TO_SPACE1; }
    if (!strcmp(valueString, "DML_OPERATOR_SPACE_TO_DEPTH1") || !strcmp(valueString, "SPACE_TO_DEPTH1")) { return DML_OPERATOR_SPACE_TO_DEPTH1; }
    if (!strcmp(valueString, "DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION1") || !strcmp(valueString, "MEAN_VARIANCE_NORMALIZATION1")) { return DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION1; }
    if (!strcmp(valueString, "DML_OPERATOR_RESAMPLE1") || !strcmp(valueString, "RESAMPLE1")) { return DML_OPERATOR_RESAMPLE1; }
    if (!strcmp(valueString, "DML_OPERATOR_MATRIX_MULTIPLY_INTEGER") || !strcmp(valueString, "MATRIX_MULTIPLY_INTEGER")) { return DML_OPERATOR_MATRIX_MULTIPLY_INTEGER; }
    if (!strcmp(valueString, "DML_OPERATOR_QUANTIZED_LINEAR_MATRIX_MULTIPLY") || !strcmp(valueString, "QUANTIZED_LINEAR_MATRIX_MULTIPLY")) { return DML_OPERATOR_QUANTIZED_LINEAR_MATRIX_MULTIPLY; }
    if (!strcmp(valueString, "DML_OPERATOR_CONVOLUTION_INTEGER") || !strcmp(valueString, "CONVOLUTION_INTEGER")) { return DML_OPERATOR_CONVOLUTION_INTEGER; }
    if (!strcmp(valueString, "DML_OPERATOR_QUANTIZED_LINEAR_CONVOLUTION") || !strcmp(valueString, "QUANTIZED_LINEAR_CONVOLUTION")) { return DML_OPERATOR_QUANTIZED_LINEAR_CONVOLUTION; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_BIT_AND") || !strcmp(valueString, "ELEMENT_WISE_BIT_AND")) { return DML_OPERATOR_ELEMENT_WISE_BIT_AND; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_BIT_OR") || !strcmp(valueString, "ELEMENT_WISE_BIT_OR")) { return DML_OPERATOR_ELEMENT_WISE_BIT_OR; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_BIT_XOR") || !strcmp(valueString, "ELEMENT_WISE_BIT_XOR")) { return DML_OPERATOR_ELEMENT_WISE_BIT_XOR; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_BIT_NOT") || !strcmp(valueString, "ELEMENT_WISE_BIT_NOT")) { return DML_OPERATOR_ELEMENT_WISE_BIT_NOT; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_BIT_COUNT") || !strcmp(valueString, "ELEMENT_WISE_BIT_COUNT")) { return DML_OPERATOR_ELEMENT_WISE_BIT_COUNT; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_RELU_GRAD") || !strcmp(valueString, "ACTIVATION_RELU_GRAD")) { return DML_OPERATOR_ACTIVATION_RELU_GRAD; }
    if (!strcmp(valueString, "DML_OPERATOR_AVERAGE_POOLING_GRAD") || !strcmp(valueString, "AVERAGE_POOLING_GRAD")) { return DML_OPERATOR_AVERAGE_POOLING_GRAD; }
    if (!strcmp(valueString, "DML_OPERATOR_MAX_POOLING_GRAD") || !strcmp(valueString, "MAX_POOLING_GRAD")) { return DML_OPERATOR_MAX_POOLING_GRAD; }
    if (!strcmp(valueString, "DML_OPERATOR_RANDOM_GENERATOR") || !strcmp(valueString, "RANDOM_GENERATOR")) { return DML_OPERATOR_RANDOM_GENERATOR; }
    if (!strcmp(valueString, "DML_OPERATOR_NONZERO_COORDINATES") || !strcmp(valueString, "NONZERO_COORDINATES")) { return DML_OPERATOR_NONZERO_COORDINATES; }
    if (!strcmp(valueString, "DML_OPERATOR_RESAMPLE_GRAD") || !strcmp(valueString, "RESAMPLE_GRAD")) { return DML_OPERATOR_RESAMPLE_GRAD; }
    if (!strcmp(valueString, "DML_OPERATOR_SLICE_GRAD") || !strcmp(valueString, "SLICE_GRAD")) { return DML_OPERATOR_SLICE_GRAD; }
    if (!strcmp(valueString, "DML_OPERATOR_ADAM_OPTIMIZER") || !strcmp(valueString, "ADAM_OPTIMIZER")) { return DML_OPERATOR_ADAM_OPTIMIZER; }
    if (!strcmp(valueString, "DML_OPERATOR_ARGMIN") || !strcmp(valueString, "ARGMIN")) { return DML_OPERATOR_ARGMIN; }
    if (!strcmp(valueString, "DML_OPERATOR_ARGMAX") || !strcmp(valueString, "ARGMAX")) { return DML_OPERATOR_ARGMAX; }
    if (!strcmp(valueString, "DML_OPERATOR_ROI_ALIGN") || !strcmp(valueString, "ROI_ALIGN")) { return DML_OPERATOR_ROI_ALIGN; }
    if (!strcmp(valueString, "DML_OPERATOR_GATHER_ND1") || !strcmp(valueString, "GATHER_ND1")) { return DML_OPERATOR_GATHER_ND1; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_ATAN_YX") || !strcmp(valueString, "ELEMENT_WISE_ATAN_YX")) { return DML_OPERATOR_ELEMENT_WISE_ATAN_YX; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD") || !strcmp(valueString, "ELEMENT_WISE_CLIP_GRAD")) { return DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_DIFFERENCE_SQUARE") || !strcmp(valueString, "ELEMENT_WISE_DIFFERENCE_SQUARE")) { return DML_OPERATOR_ELEMENT_WISE_DIFFERENCE_SQUARE; }
    if (!strcmp(valueString, "DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION_GRAD") || !strcmp(valueString, "LOCAL_RESPONSE_NORMALIZATION_GRAD")) { return DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION_GRAD; }
    if (!strcmp(valueString, "DML_OPERATOR_CUMULATIVE_PRODUCT") || !strcmp(valueString, "CUMULATIVE_PRODUCT")) { return DML_OPERATOR_CUMULATIVE_PRODUCT; }
    if (!strcmp(valueString, "DML_OPERATOR_BATCH_NORMALIZATION_GRAD") || !strcmp(valueString, "BATCH_NORMALIZATION_GRAD")) { return DML_OPERATOR_BATCH_NORMALIZATION_GRAD; }
    if (!strcmp(valueString, "DML_OPERATOR_BATCH_NORMALIZATION_TRAINING_GRAD") || !strcmp(valueString, "BATCH_NORMALIZATION_TRAINING_GRAD")) { return DML_OPERATOR_BATCH_NORMALIZATION_TRAINING_GRAD; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_QUANTIZED_LINEAR_ADD") || !strcmp(valueString, "ELEMENT_WISE_QUANTIZED_LINEAR_ADD")) { return DML_OPERATOR_ELEMENT_WISE_QUANTIZED_LINEAR_ADD; }
    if (!strcmp(valueString, "DML_OPERATOR_DYNAMIC_QUANTIZE_LINEAR") || !strcmp(valueString, "DYNAMIC_QUANTIZE_LINEAR")) { return DML_OPERATOR_DYNAMIC_QUANTIZE_LINEAR; }
    if (!strcmp(valueString, "DML_OPERATOR_ROI_ALIGN1") || !strcmp(valueString, "ROI_ALIGN1")) { return DML_OPERATOR_ROI_ALIGN1; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_CLIP1") || !strcmp(valueString, "ELEMENT_WISE_CLIP1")) { return DML_OPERATOR_ELEMENT_WISE_CLIP1; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD1") || !strcmp(valueString, "ELEMENT_WISE_CLIP_GRAD1")) { return DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD1; }
    if (!strcmp(valueString, "DML_OPERATOR_ELEMENT_WISE_NEGATE") || !strcmp(valueString, "ELEMENT_WISE_NEGATE")) { return DML_OPERATOR_ELEMENT_WISE_NEGATE; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_GELU") || !strcmp(valueString, "ACTIVATION_GELU")) { return DML_OPERATOR_ACTIVATION_GELU; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_SWISH") || !strcmp(valueString, "ACTIVATION_SWISH")) { return DML_OPERATOR_ACTIVATION_SWISH; }
    if (!strcmp(valueString, "DML_OPERATOR_ACTIVATION_HARD_SWISH") || !strcmp(valueString, "ACTIVATION_HARD_SWISH")) { return DML_OPERATOR_ACTIVATION_HARD_SWISH; }
    if (!strcmp(valueString, "DML_OPERATOR_RESAMPLE2") || !strcmp(valueString, "RESAMPLE2")) { return DML_OPERATOR_RESAMPLE2; }
    if (!strcmp(valueString, "DML_OPERATOR_RESAMPLE_GRAD1") || !strcmp(valueString, "RESAMPLE_GRAD1")) { return DML_OPERATOR_RESAMPLE_GRAD1; }
    if (!strcmp(valueString, "DML_OPERATOR_DIAGONAL_MATRIX1") || !strcmp(valueString, "DIAGONAL_MATRIX1")) { return DML_OPERATOR_DIAGONAL_MATRIX1; }
    if (!strcmp(valueString, "DML_OPERATOR_MULTIHEAD_ATTENTION") || !strcmp(valueString, "MULTIHEAD_ATTENTION")) { return DML_OPERATOR_MULTIHEAD_ATTENTION; }
    if (!strcmp(valueString, "DML_OPERATOR_QUANTIZED_LINEAR_AVERAGE_POOLING") || !strcmp(valueString, "QUANTIZED_LINEAR_AVERAGE_POOLING")) { return DML_OPERATOR_QUANTIZED_LINEAR_AVERAGE_POOLING; }
    if (!strcmp(valueString, "DML_OPERATOR_MATRIX_MULTIPLY_INTEGER_TO_FLOAT") || !strcmp(valueString, "MATRIX_MULTIPLY_INTEGER_TO_FLOAT")) { return DML_OPERATOR_MATRIX_MULTIPLY_INTEGER_TO_FLOAT; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_OPERATOR_TYPE.", valueString));
}

DML_OPERATOR_TYPE ParseDmlOperatorTypeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_OPERATOR_TYPE defaultValue)
{
    return ParseFieldHelper<DML_OPERATOR_TYPE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlOperatorType(value); 
    });
}

DML_BINDING_TYPE ParseDmlBindingType(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_BINDING_TYPE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_BINDING_TYPE_NONE") || !strcmp(valueString, "NONE")) { return DML_BINDING_TYPE_NONE; }
    if (!strcmp(valueString, "DML_BINDING_TYPE_BUFFER") || !strcmp(valueString, "BUFFER")) { return DML_BINDING_TYPE_BUFFER; }
    if (!strcmp(valueString, "DML_BINDING_TYPE_BUFFER_ARRAY") || !strcmp(valueString, "BUFFER_ARRAY")) { return DML_BINDING_TYPE_BUFFER_ARRAY; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_BINDING_TYPE.", valueString));
}

DML_BINDING_TYPE ParseDmlBindingTypeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_BINDING_TYPE defaultValue)
{
    return ParseFieldHelper<DML_BINDING_TYPE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlBindingType(value); 
    });
}

DML_REDUCE_FUNCTION ParseDmlReduceFunction(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_REDUCE_FUNCTION must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_ARGMAX") || !strcmp(valueString, "ARGMAX")) { return DML_REDUCE_FUNCTION_ARGMAX; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_ARGMIN") || !strcmp(valueString, "ARGMIN")) { return DML_REDUCE_FUNCTION_ARGMIN; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_AVERAGE") || !strcmp(valueString, "AVERAGE")) { return DML_REDUCE_FUNCTION_AVERAGE; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_L1") || !strcmp(valueString, "L1")) { return DML_REDUCE_FUNCTION_L1; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_L2") || !strcmp(valueString, "L2")) { return DML_REDUCE_FUNCTION_L2; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_LOG_SUM") || !strcmp(valueString, "LOG_SUM")) { return DML_REDUCE_FUNCTION_LOG_SUM; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_LOG_SUM_EXP") || !strcmp(valueString, "LOG_SUM_EXP")) { return DML_REDUCE_FUNCTION_LOG_SUM_EXP; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_MAX") || !strcmp(valueString, "MAX")) { return DML_REDUCE_FUNCTION_MAX; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_MIN") || !strcmp(valueString, "MIN")) { return DML_REDUCE_FUNCTION_MIN; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_MULTIPLY") || !strcmp(valueString, "MULTIPLY")) { return DML_REDUCE_FUNCTION_MULTIPLY; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_SUM") || !strcmp(valueString, "SUM")) { return DML_REDUCE_FUNCTION_SUM; }
    if (!strcmp(valueString, "DML_REDUCE_FUNCTION_SUM_SQUARE") || !strcmp(valueString, "SUM_SQUARE")) { return DML_REDUCE_FUNCTION_SUM_SQUARE; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_REDUCE_FUNCTION.", valueString));
}

DML_REDUCE_FUNCTION ParseDmlReduceFunctionField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_REDUCE_FUNCTION defaultValue)
{
    return ParseFieldHelper<DML_REDUCE_FUNCTION>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlReduceFunction(value); 
    });
}

DML_MATRIX_TRANSFORM ParseDmlMatrixTransform(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_MATRIX_TRANSFORM must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_MATRIX_TRANSFORM_NONE") || !strcmp(valueString, "NONE")) { return DML_MATRIX_TRANSFORM_NONE; }
    if (!strcmp(valueString, "DML_MATRIX_TRANSFORM_TRANSPOSE") || !strcmp(valueString, "TRANSPOSE")) { return DML_MATRIX_TRANSFORM_TRANSPOSE; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_MATRIX_TRANSFORM.", valueString));
}

DML_MATRIX_TRANSFORM ParseDmlMatrixTransformField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_MATRIX_TRANSFORM defaultValue)
{
    return ParseFieldHelper<DML_MATRIX_TRANSFORM>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlMatrixTransform(value); 
    });
}

DML_CONVOLUTION_MODE ParseDmlConvolutionMode(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_CONVOLUTION_MODE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_CONVOLUTION_MODE_CONVOLUTION") || !strcmp(valueString, "CONVOLUTION")) { return DML_CONVOLUTION_MODE_CONVOLUTION; }
    if (!strcmp(valueString, "DML_CONVOLUTION_MODE_CROSS_CORRELATION") || !strcmp(valueString, "CROSS_CORRELATION")) { return DML_CONVOLUTION_MODE_CROSS_CORRELATION; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_CONVOLUTION_MODE.", valueString));
}

DML_CONVOLUTION_MODE ParseDmlConvolutionModeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_CONVOLUTION_MODE defaultValue)
{
    return ParseFieldHelper<DML_CONVOLUTION_MODE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlConvolutionMode(value); 
    });
}

DML_CONVOLUTION_DIRECTION ParseDmlConvolutionDirection(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_CONVOLUTION_DIRECTION must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_CONVOLUTION_DIRECTION_FORWARD") || !strcmp(valueString, "FORWARD")) { return DML_CONVOLUTION_DIRECTION_FORWARD; }
    if (!strcmp(valueString, "DML_CONVOLUTION_DIRECTION_BACKWARD") || !strcmp(valueString, "BACKWARD")) { return DML_CONVOLUTION_DIRECTION_BACKWARD; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_CONVOLUTION_DIRECTION.", valueString));
}

DML_CONVOLUTION_DIRECTION ParseDmlConvolutionDirectionField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_CONVOLUTION_DIRECTION defaultValue)
{
    return ParseFieldHelper<DML_CONVOLUTION_DIRECTION>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlConvolutionDirection(value); 
    });
}

DML_PADDING_MODE ParseDmlPaddingMode(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_PADDING_MODE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_PADDING_MODE_CONSTANT") || !strcmp(valueString, "CONSTANT")) { return DML_PADDING_MODE_CONSTANT; }
    if (!strcmp(valueString, "DML_PADDING_MODE_EDGE") || !strcmp(valueString, "EDGE")) { return DML_PADDING_MODE_EDGE; }
    if (!strcmp(valueString, "DML_PADDING_MODE_REFLECTION") || !strcmp(valueString, "REFLECTION")) { return DML_PADDING_MODE_REFLECTION; }
    if (!strcmp(valueString, "DML_PADDING_MODE_SYMMETRIC") || !strcmp(valueString, "SYMMETRIC")) { return DML_PADDING_MODE_SYMMETRIC; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_PADDING_MODE.", valueString));
}

DML_PADDING_MODE ParseDmlPaddingModeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_PADDING_MODE defaultValue)
{
    return ParseFieldHelper<DML_PADDING_MODE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlPaddingMode(value); 
    });
}

DML_INTERPOLATION_MODE ParseDmlInterpolationMode(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_INTERPOLATION_MODE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_INTERPOLATION_MODE_NEAREST_NEIGHBOR") || !strcmp(valueString, "NEAREST_NEIGHBOR")) { return DML_INTERPOLATION_MODE_NEAREST_NEIGHBOR; }
    if (!strcmp(valueString, "DML_INTERPOLATION_MODE_LINEAR") || !strcmp(valueString, "LINEAR")) { return DML_INTERPOLATION_MODE_LINEAR; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_INTERPOLATION_MODE.", valueString));
}

DML_INTERPOLATION_MODE ParseDmlInterpolationModeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_INTERPOLATION_MODE defaultValue)
{
    return ParseFieldHelper<DML_INTERPOLATION_MODE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlInterpolationMode(value); 
    });
}

DML_RECURRENT_NETWORK_DIRECTION ParseDmlRecurrentNetworkDirection(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_RECURRENT_NETWORK_DIRECTION must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_RECURRENT_NETWORK_DIRECTION_FORWARD") || !strcmp(valueString, "FORWARD")) { return DML_RECURRENT_NETWORK_DIRECTION_FORWARD; }
    if (!strcmp(valueString, "DML_RECURRENT_NETWORK_DIRECTION_BACKWARD") || !strcmp(valueString, "BACKWARD")) { return DML_RECURRENT_NETWORK_DIRECTION_BACKWARD; }
    if (!strcmp(valueString, "DML_RECURRENT_NETWORK_DIRECTION_BIDIRECTIONAL") || !strcmp(valueString, "BIDIRECTIONAL")) { return DML_RECURRENT_NETWORK_DIRECTION_BIDIRECTIONAL; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_RECURRENT_NETWORK_DIRECTION.", valueString));
}

DML_RECURRENT_NETWORK_DIRECTION ParseDmlRecurrentNetworkDirectionField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_RECURRENT_NETWORK_DIRECTION defaultValue)
{
    return ParseFieldHelper<DML_RECURRENT_NETWORK_DIRECTION>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlRecurrentNetworkDirection(value); 
    });
}

DML_FEATURE ParseDmlFeature(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_FEATURE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_FEATURE_TENSOR_DATA_TYPE_SUPPORT") || !strcmp(valueString, "TENSOR_DATA_TYPE_SUPPORT")) { return DML_FEATURE_TENSOR_DATA_TYPE_SUPPORT; }
    if (!strcmp(valueString, "DML_FEATURE_FEATURE_LEVELS") || !strcmp(valueString, "FEATURE_LEVELS")) { return DML_FEATURE_FEATURE_LEVELS; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_FEATURE.", valueString));
}

DML_FEATURE ParseDmlFeatureField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_FEATURE defaultValue)
{
    return ParseFieldHelper<DML_FEATURE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlFeature(value); 
    });
}

DML_FEATURE_LEVEL ParseDmlFeatureLevel(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_FEATURE_LEVEL must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_1_0") || !strcmp(valueString, "1_0")) { return DML_FEATURE_LEVEL_1_0; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_2_0") || !strcmp(valueString, "2_0")) { return DML_FEATURE_LEVEL_2_0; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_2_1") || !strcmp(valueString, "2_1")) { return DML_FEATURE_LEVEL_2_1; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_3_0") || !strcmp(valueString, "3_0")) { return DML_FEATURE_LEVEL_3_0; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_3_1") || !strcmp(valueString, "3_1")) { return DML_FEATURE_LEVEL_3_1; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_4_0") || !strcmp(valueString, "4_0")) { return DML_FEATURE_LEVEL_4_0; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_4_1") || !strcmp(valueString, "4_1")) { return DML_FEATURE_LEVEL_4_1; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_5_0") || !strcmp(valueString, "5_0")) { return DML_FEATURE_LEVEL_5_0; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_5_1") || !strcmp(valueString, "5_1")) { return DML_FEATURE_LEVEL_5_1; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_5_2") || !strcmp(valueString, "5_2")) { return DML_FEATURE_LEVEL_5_2; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_6_0") || !strcmp(valueString, "6_0")) { return DML_FEATURE_LEVEL_6_0; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_6_1") || !strcmp(valueString, "6_1")) { return DML_FEATURE_LEVEL_6_1; }
    if (!strcmp(valueString, "DML_FEATURE_LEVEL_6_2") || !strcmp(valueString, "6_2")) { return DML_FEATURE_LEVEL_6_2; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_FEATURE_LEVEL.", valueString));
}

DML_FEATURE_LEVEL ParseDmlFeatureLevelField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_FEATURE_LEVEL defaultValue)
{
    return ParseFieldHelper<DML_FEATURE_LEVEL>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlFeatureLevel(value); 
    });
}

DML_IS_INFINITY_MODE ParseDmlIsInfinityMode(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_IS_INFINITY_MODE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_IS_INFINITY_MODE_EITHER") || !strcmp(valueString, "EITHER")) { return DML_IS_INFINITY_MODE_EITHER; }
    if (!strcmp(valueString, "DML_IS_INFINITY_MODE_POSITIVE") || !strcmp(valueString, "POSITIVE")) { return DML_IS_INFINITY_MODE_POSITIVE; }
    if (!strcmp(valueString, "DML_IS_INFINITY_MODE_NEGATIVE") || !strcmp(valueString, "NEGATIVE")) { return DML_IS_INFINITY_MODE_NEGATIVE; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_IS_INFINITY_MODE.", valueString));
}

DML_IS_INFINITY_MODE ParseDmlIsInfinityModeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_IS_INFINITY_MODE defaultValue)
{
    return ParseFieldHelper<DML_IS_INFINITY_MODE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlIsInfinityMode(value); 
    });
}

DML_DEPTH_SPACE_ORDER ParseDmlDepthSpaceOrder(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_DEPTH_SPACE_ORDER must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_DEPTH_SPACE_ORDER_DEPTH_COLUMN_ROW") || !strcmp(valueString, "DEPTH_COLUMN_ROW")) { return DML_DEPTH_SPACE_ORDER_DEPTH_COLUMN_ROW; }
    if (!strcmp(valueString, "DML_DEPTH_SPACE_ORDER_COLUMN_ROW_DEPTH") || !strcmp(valueString, "COLUMN_ROW_DEPTH")) { return DML_DEPTH_SPACE_ORDER_COLUMN_ROW_DEPTH; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_DEPTH_SPACE_ORDER.", valueString));
}

DML_DEPTH_SPACE_ORDER ParseDmlDepthSpaceOrderField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_DEPTH_SPACE_ORDER defaultValue)
{
    return ParseFieldHelper<DML_DEPTH_SPACE_ORDER>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlDepthSpaceOrder(value); 
    });
}

DML_AXIS_DIRECTION ParseDmlAxisDirection(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_AXIS_DIRECTION must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_AXIS_DIRECTION_INCREASING") || !strcmp(valueString, "INCREASING")) { return DML_AXIS_DIRECTION_INCREASING; }
    if (!strcmp(valueString, "DML_AXIS_DIRECTION_DECREASING") || !strcmp(valueString, "DECREASING")) { return DML_AXIS_DIRECTION_DECREASING; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_AXIS_DIRECTION.", valueString));
}

DML_AXIS_DIRECTION ParseDmlAxisDirectionField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_AXIS_DIRECTION defaultValue)
{
    return ParseFieldHelper<DML_AXIS_DIRECTION>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlAxisDirection(value); 
    });
}

DML_ROUNDING_MODE ParseDmlRoundingMode(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_ROUNDING_MODE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_ROUNDING_MODE_HALVES_TO_NEAREST_EVEN") || !strcmp(valueString, "HALVES_TO_NEAREST_EVEN")) { return DML_ROUNDING_MODE_HALVES_TO_NEAREST_EVEN; }
    if (!strcmp(valueString, "DML_ROUNDING_MODE_TOWARD_ZERO") || !strcmp(valueString, "TOWARD_ZERO")) { return DML_ROUNDING_MODE_TOWARD_ZERO; }
    if (!strcmp(valueString, "DML_ROUNDING_MODE_TOWARD_INFINITY") || !strcmp(valueString, "TOWARD_INFINITY")) { return DML_ROUNDING_MODE_TOWARD_INFINITY; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_ROUNDING_MODE.", valueString));
}

DML_ROUNDING_MODE ParseDmlRoundingModeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_ROUNDING_MODE defaultValue)
{
    return ParseFieldHelper<DML_ROUNDING_MODE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlRoundingMode(value); 
    });
}

DML_RANDOM_GENERATOR_TYPE ParseDmlRandomGeneratorType(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_RANDOM_GENERATOR_TYPE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_RANDOM_GENERATOR_TYPE_PHILOX_4X32_10") || !strcmp(valueString, "PHILOX_4X32_10")) { return DML_RANDOM_GENERATOR_TYPE_PHILOX_4X32_10; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_RANDOM_GENERATOR_TYPE.", valueString));
}

DML_RANDOM_GENERATOR_TYPE ParseDmlRandomGeneratorTypeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_RANDOM_GENERATOR_TYPE defaultValue)
{
    return ParseFieldHelper<DML_RANDOM_GENERATOR_TYPE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlRandomGeneratorType(value); 
    });
}

DML_MULTIHEAD_ATTENTION_MASK_TYPE ParseDmlMultiheadAttentionMaskType(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("DML_MULTIHEAD_ATTENTION_MASK_TYPE must be a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_MULTIHEAD_ATTENTION_MASK_TYPE_NONE") || !strcmp(valueString, "NONE")) { return DML_MULTIHEAD_ATTENTION_MASK_TYPE_NONE; }
    if (!strcmp(valueString, "DML_MULTIHEAD_ATTENTION_MASK_TYPE_KEY_SEQUENCE_LENGTH") || !strcmp(valueString, "KEY_SEQUENCE_LENGTH")) { return DML_MULTIHEAD_ATTENTION_MASK_TYPE_KEY_SEQUENCE_LENGTH; }
    if (!strcmp(valueString, "DML_MULTIHEAD_ATTENTION_MASK_TYPE_KEY_SEQUENCE_END_START") || !strcmp(valueString, "KEY_SEQUENCE_END_START")) { return DML_MULTIHEAD_ATTENTION_MASK_TYPE_KEY_SEQUENCE_END_START; }
    if (!strcmp(valueString, "DML_MULTIHEAD_ATTENTION_MASK_TYPE_KEY_QUERY_SEQUENCE_LENGTH_START_END") || !strcmp(valueString, "KEY_QUERY_SEQUENCE_LENGTH_START_END")) { return DML_MULTIHEAD_ATTENTION_MASK_TYPE_KEY_QUERY_SEQUENCE_LENGTH_START_END; }
    if (!strcmp(valueString, "DML_MULTIHEAD_ATTENTION_MASK_TYPE_BOOLEAN") || !strcmp(valueString, "BOOLEAN")) { return DML_MULTIHEAD_ATTENTION_MASK_TYPE_BOOLEAN; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_MULTIHEAD_ATTENTION_MASK_TYPE.", valueString));
}

DML_MULTIHEAD_ATTENTION_MASK_TYPE ParseDmlMultiheadAttentionMaskTypeField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_MULTIHEAD_ATTENTION_MASK_TYPE defaultValue)
{
    return ParseFieldHelper<DML_MULTIHEAD_ATTENTION_MASK_TYPE>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlMultiheadAttentionMaskType(value); 
    });
}

// ====================================================================================================
// DIRECTML FLAGS
// ====================================================================================================

DML_TENSOR_FLAGS ParseSingleFlagFromDmlTensorFlags(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("Expected a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_TENSOR_FLAG_NONE") || !strcmp(valueString, "NONE")) { return DML_TENSOR_FLAG_NONE; }
    if (!strcmp(valueString, "DML_TENSOR_FLAG_OWNED_BY_DML") || !strcmp(valueString, "OWNED_BY_DML")) { return DML_TENSOR_FLAG_OWNED_BY_DML; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_TENSOR_FLAGS.", valueString));
}

DML_TENSOR_FLAGS ParseDmlTensorFlags(const rapidjson::Value& value)
{
    return ParseFlags<DML_TENSOR_FLAGS>(value, ParseSingleFlagFromDmlTensorFlags);
}

DML_TENSOR_FLAGS ParseDmlTensorFlagsField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_TENSOR_FLAGS defaultValue)
{
    return ParseFieldHelper<DML_TENSOR_FLAGS>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlTensorFlags(value); 
    });
}

DML_EXECUTION_FLAGS ParseSingleFlagFromDmlExecutionFlags(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("Expected a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_EXECUTION_FLAG_NONE") || !strcmp(valueString, "NONE")) { return DML_EXECUTION_FLAG_NONE; }
    if (!strcmp(valueString, "DML_EXECUTION_FLAG_ALLOW_HALF_PRECISION_COMPUTATION") || !strcmp(valueString, "ALLOW_HALF_PRECISION_COMPUTATION")) { return DML_EXECUTION_FLAG_ALLOW_HALF_PRECISION_COMPUTATION; }
    if (!strcmp(valueString, "DML_EXECUTION_FLAG_DISABLE_META_COMMANDS") || !strcmp(valueString, "DISABLE_META_COMMANDS")) { return DML_EXECUTION_FLAG_DISABLE_META_COMMANDS; }
    if (!strcmp(valueString, "DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE") || !strcmp(valueString, "DESCRIPTORS_VOLATILE")) { return DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_EXECUTION_FLAGS.", valueString));
}

DML_EXECUTION_FLAGS ParseDmlExecutionFlags(const rapidjson::Value& value)
{
    return ParseFlags<DML_EXECUTION_FLAGS>(value, ParseSingleFlagFromDmlExecutionFlags);
}

DML_EXECUTION_FLAGS ParseDmlExecutionFlagsField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_EXECUTION_FLAGS defaultValue)
{
    return ParseFieldHelper<DML_EXECUTION_FLAGS>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlExecutionFlags(value); 
    });
}

DML_CREATE_DEVICE_FLAGS ParseSingleFlagFromDmlCreateDeviceFlags(const rapidjson::Value& value)
{
    if (value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("Expected a string.");
    }
    auto valueString = value.GetString();
    if (!strcmp(valueString, "DML_CREATE_DEVICE_FLAG_NONE") || !strcmp(valueString, "NONE")) { return DML_CREATE_DEVICE_FLAG_NONE; }
    if (!strcmp(valueString, "DML_CREATE_DEVICE_FLAG_DEBUG") || !strcmp(valueString, "DEBUG")) { return DML_CREATE_DEVICE_FLAG_DEBUG; }
    throw std::invalid_argument(fmt::format("'{}' is not a recognized value for DML_CREATE_DEVICE_FLAGS.", valueString));
}

DML_CREATE_DEVICE_FLAGS ParseDmlCreateDeviceFlags(const rapidjson::Value& value)
{
    return ParseFlags<DML_CREATE_DEVICE_FLAGS>(value, ParseSingleFlagFromDmlCreateDeviceFlags);
}

DML_CREATE_DEVICE_FLAGS ParseDmlCreateDeviceFlagsField(const rapidjson::Value& object, std::string_view fieldName, bool required, DML_CREATE_DEVICE_FLAGS defaultValue)
{
    return ParseFieldHelper<DML_CREATE_DEVICE_FLAGS>(object, fieldName, required, defaultValue, [](auto& value){
        return ParseDmlCreateDeviceFlags(value); 
    });
}

// ====================================================================================================
// DIRECTML OPERATORS
// ====================================================================================================

DML_OPERATOR_DESC* ParseDmlElementWiseIdentityOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_IDENTITY;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAbsOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ABS_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ABS;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ABS_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAcosOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ACOS_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ACOS;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ACOS_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAddOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ADD_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ADD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ADD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAsinOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ASIN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ASIN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ASIN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAtanOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ATAN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ATAN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ATAN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseCeilOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_CEIL_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_CEIL;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_CEIL_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseClipOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_CLIP_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    desc->Min = ParseFloat32Field(value, "Min", true);
    desc->Max = ParseFloat32Field(value, "Max", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_CLIP;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_CLIP_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseClip1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_CLIP1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    desc->MinMaxDataType = ParseDmlTensorDataTypeField(value, "MinMaxDataType", true, {});
    desc->Min = *ParseDmlScalarUnionField(value, "Min", "MinMaxDataType", allocator, true);
    desc->Max = *ParseDmlScalarUnionField(value, "Max", "MinMaxDataType", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_CLIP1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_CLIP1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseClipGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->Min = ParseFloat32Field(value, "Min", true);
    desc->Max = ParseFloat32Field(value, "Max", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseClipGrad1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_CLIP_GRAD1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->MinMaxDataType = ParseDmlTensorDataTypeField(value, "MinMaxDataType", true, {});
    desc->Min = *ParseDmlScalarUnionField(value, "Min", "MinMaxDataType", allocator, true);
    desc->Max = *ParseDmlScalarUnionField(value, "Max", "MinMaxDataType", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_CLIP_GRAD1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseCosOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_COS_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_COS;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_COS_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseDivideOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_DIVIDE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseExpOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_EXP_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_EXP;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_EXP_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseFloorOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_FLOOR_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_FLOOR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_FLOOR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOG_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOG;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOG_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogicalAndOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOGICAL_AND;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogicalEqualsOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOGICAL_EQUALS;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogicalGreaterThanOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogicalLessThanOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogicalGreaterThanOrEqualOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogicalLessThanOrEqualOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogicalNotOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOGICAL_NOT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogicalOrOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOGICAL_OR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseLogicalXorOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_LOGICAL_XOR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseMaxOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_MAX_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_MAX;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_MAX_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseMeanOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_MEAN_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_MEAN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_MEAN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseMinOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_MIN_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_MIN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_MIN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseMultiplyOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_MULTIPLY;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWisePowOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_POW_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->ExponentTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ExponentTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_POW;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_POW_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"ExponentTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseConstantPowOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    desc->Exponent = ParseFloat32Field(value, "Exponent", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_CONSTANT_POW;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseRecipOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_RECIP_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_RECIP;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_RECIP_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseSinOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_SIN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_SIN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_SIN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseSqrtOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_SQRT_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_SQRT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_SQRT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseDifferenceSquareOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_DIFFERENCE_SQUARE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAtanYxOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ATAN_YX;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseSubtractOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_SUBTRACT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseTanOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_TAN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_TAN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_TAN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseThresholdOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    desc->Min = ParseFloat32Field(value, "Min", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_THRESHOLD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseQuantizeLinearOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->ScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ScaleTensor", allocator, true);
    desc->ZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ZeroPointTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_QUANTIZE_LINEAR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"ScaleTensor", 1, true});
    bindPoints.inputs.push_back({"ZeroPointTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseDequantizeLinearOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->ScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ScaleTensor", allocator, true);
    desc->ZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ZeroPointTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_DEQUANTIZE_LINEAR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"ScaleTensor", 1, true});
    bindPoints.inputs.push_back({"ZeroPointTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlConvolutionOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_CONVOLUTION_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->FilterTensor = fused ? nullptr : ParseDmlTensorDescField(value, "FilterTensor", allocator, true);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Mode = ParseDmlConvolutionModeField(value, "Mode", true, {});
    desc->Direction = ParseDmlConvolutionDirectionField(value, "Direction", true, {});
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->Dilations = AsPointer(ParseUInt32ArrayField(value, "Dilations", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->OutputPadding = AsPointer(ParseUInt32ArrayField(value, "OutputPadding", allocator, true));
    desc->GroupCount = ParseUInt32Field(value, "GroupCount", true);
    desc->FusedActivation = ParseDmlOperatorDescField(value, "FusedActivation", true, allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_CONVOLUTION;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_CONVOLUTION_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"FilterTensor", 1, true});
    bindPoints.inputs.push_back({"BiasTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlGemmOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_GEMM_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->CTensor = fused ? nullptr : ParseDmlTensorDescField(value, "CTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->TransA = ParseDmlMatrixTransformField(value, "TransA", true, {});
    desc->TransB = ParseDmlMatrixTransformField(value, "TransB", true, {});
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    desc->Beta = ParseFloat32Field(value, "Beta", true);
    desc->FusedActivation = ParseDmlOperatorDescField(value, "FusedActivation", true, allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_GEMM;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_GEMM_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.inputs.push_back({"CTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlReduceOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_REDUCE_OPERATOR_DESC>();
    desc->Function = ParseDmlReduceFunctionField(value, "Function", true, {});
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->AxisCount = ParseUInt32Field(value, "AxisCount", true);
    desc->Axes = AsPointer(ParseUInt32ArrayField(value, "Axes", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_REDUCE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_REDUCE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlArgminOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ARGMIN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->AxisCount = ParseUInt32Field(value, "AxisCount", true);
    desc->Axes = AsPointer(ParseUInt32ArrayField(value, "Axes", allocator, true));
    desc->AxisDirection = ParseDmlAxisDirectionField(value, "AxisDirection", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ARGMIN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ARGMIN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlArgmaxOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ARGMAX_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->AxisCount = ParseUInt32Field(value, "AxisCount", true);
    desc->Axes = AsPointer(ParseUInt32ArrayField(value, "Axes", allocator, true));
    desc->AxisDirection = ParseDmlAxisDirectionField(value, "AxisDirection", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ARGMAX;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ARGMAX_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlAveragePoolingOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_AVERAGE_POOLING_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->IncludePadding = ParseBoolField(value, "IncludePadding", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_AVERAGE_POOLING;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_AVERAGE_POOLING_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlAveragePooling1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_AVERAGE_POOLING1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->Dilations = AsPointer(ParseUInt32ArrayField(value, "Dilations", allocator, true));
    desc->IncludePadding = ParseBoolField(value, "IncludePadding", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_AVERAGE_POOLING1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_AVERAGE_POOLING1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlLpPoolingOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_LP_POOLING_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->P = ParseUInt32Field(value, "P", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_LP_POOLING;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_LP_POOLING_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlLpPooling1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_LP_POOLING1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->Dilations = AsPointer(ParseUInt32ArrayField(value, "Dilations", allocator, true));
    desc->P = ParseUInt32Field(value, "P", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_LP_POOLING1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_LP_POOLING1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMaxPoolingOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MAX_POOLING_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MAX_POOLING;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MAX_POOLING_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMaxPooling1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MAX_POOLING1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->OutputIndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputIndicesTensor", allocator, false);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MAX_POOLING1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MAX_POOLING1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputIndicesTensor", 1, false});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlRoiPoolingOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ROI_POOLING_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->ROITensor = fused ? nullptr : ParseDmlTensorDescField(value, "ROITensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->SpatialScale = ParseFloat32Field(value, "SpatialScale", true);
    desc->PooledSize = *ParseDmlSize2dField(value, "PooledSize", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ROI_POOLING;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ROI_POOLING_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"ROITensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlSliceOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_SLICE_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Offsets = AsPointer(ParseUInt32ArrayField(value, "Offsets", allocator, true));
    desc->Sizes = AsPointer(ParseUInt32ArrayField(value, "Sizes", allocator, true));
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_SLICE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_SLICE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlCastOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_CAST_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_CAST;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_CAST_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlSplitOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_SPLIT_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputCount = ParseUInt32Field(value, "OutputCount", true);
    desc->OutputTensors = fused ? nullptr : AsPointer(ParseDmlTensorDescArrayField(value, "OutputTensors", allocator, true));
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_SPLIT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_SPLIT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensors", desc.OutputCount, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlJoinOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_JOIN_OPERATOR_DESC>();
    desc->InputCount = ParseUInt32Field(value, "InputCount", true);
    desc->InputTensors = fused ? nullptr : AsPointer(ParseDmlTensorDescArrayField(value, "InputTensors", allocator, true));
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_JOIN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_JOIN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensors", desc.InputCount, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlPaddingOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_PADDING_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->PaddingMode = ParseDmlPaddingModeField(value, "PaddingMode", true, {});
    desc->PaddingValue = ParseFloat32Field(value, "PaddingValue", true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_PADDING;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_PADDING_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlPadding1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_PADDING1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->PaddingMode = ParseDmlPaddingModeField(value, "PaddingMode", true, {});
    desc->PaddingValueDataType = ParseDmlTensorDataTypeField(value, "PaddingValueDataType", true, {});
    desc->PaddingValue = *ParseDmlScalarUnionField(value, "PaddingValue", "PaddingValueDataType", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_PADDING1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_PADDING1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlValueScale2dOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_VALUE_SCALE_2D_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Scale = ParseFloat32Field(value, "Scale", true);
    desc->ChannelCount = ParseUInt32Field(value, "ChannelCount", true);
    desc->Bias = AsPointer(ParseFloat32ArrayField(value, "Bias", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_VALUE_SCALE_2D;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_VALUE_SCALE_2D_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlUpsample2dOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_UPSAMPLE_2D_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleSize = *ParseDmlSize2dField(value, "ScaleSize", allocator, true);
    desc->InterpolationMode = ParseDmlInterpolationModeField(value, "InterpolationMode", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_UPSAMPLE_2D;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_UPSAMPLE_2D_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlGatherOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_GATHER_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->IndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "IndicesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    desc->IndexDimensions = ParseUInt32Field(value, "IndexDimensions", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_GATHER;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_GATHER_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"IndicesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlSpaceToDepthOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_SPACE_TO_DEPTH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->BlockSize = ParseUInt32Field(value, "BlockSize", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_SPACE_TO_DEPTH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_SPACE_TO_DEPTH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlDepthToSpaceOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_DEPTH_TO_SPACE_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->BlockSize = ParseUInt32Field(value, "BlockSize", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_DEPTH_TO_SPACE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_DEPTH_TO_SPACE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlTileOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_TILE_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->RepeatsCount = ParseUInt32Field(value, "RepeatsCount", true);
    desc->Repeats = AsPointer(ParseUInt32ArrayField(value, "Repeats", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_TILE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_TILE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlTopKOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_TOP_K_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputValueTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputValueTensor", allocator, true);
    desc->OutputIndexTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputIndexTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    desc->K = ParseUInt32Field(value, "K", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_TOP_K;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_TOP_K_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputValueTensor", 1, true});
    bindPoints.outputs.push_back({"OutputIndexTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlBatchNormalizationOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_BATCH_NORMALIZATION_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->MeanTensor = fused ? nullptr : ParseDmlTensorDescField(value, "MeanTensor", allocator, true);
    desc->VarianceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "VarianceTensor", allocator, true);
    desc->ScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ScaleTensor", allocator, true);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Spatial = ParseBoolField(value, "Spatial", true) ? 1 : 0;
    desc->Epsilon = ParseFloat32Field(value, "Epsilon", true);
    desc->FusedActivation = ParseDmlOperatorDescField(value, "FusedActivation", true, allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_BATCH_NORMALIZATION;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_BATCH_NORMALIZATION_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"MeanTensor", 1, true});
    bindPoints.inputs.push_back({"VarianceTensor", 1, true});
    bindPoints.inputs.push_back({"ScaleTensor", 1, true});
    bindPoints.inputs.push_back({"BiasTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlBatchNormalizationGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->MeanTensor = fused ? nullptr : ParseDmlTensorDescField(value, "MeanTensor", allocator, true);
    desc->VarianceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "VarianceTensor", allocator, true);
    desc->ScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ScaleTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->OutputScaleGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputScaleGradientTensor", allocator, true);
    desc->OutputBiasGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputBiasGradientTensor", allocator, true);
    desc->Epsilon = ParseFloat32Field(value, "Epsilon", false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_BATCH_NORMALIZATION_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.inputs.push_back({"MeanTensor", 1, true});
    bindPoints.inputs.push_back({"VarianceTensor", 1, true});
    bindPoints.inputs.push_back({"ScaleTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputScaleGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputBiasGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlBatchNormalizationTrainingGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_BATCH_NORMALIZATION_TRAINING_GRAD_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->MeanTensor = fused ? nullptr : ParseDmlTensorDescField(value, "MeanTensor", allocator, true);
    desc->VarianceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "VarianceTensor", allocator, true);
    desc->ScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ScaleTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->OutputScaleGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputScaleGradientTensor", allocator, true);
    desc->OutputBiasGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputBiasGradientTensor", allocator, true);
    desc->Epsilon = ParseFloat32Field(value, "Epsilon", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_BATCH_NORMALIZATION_TRAINING_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_BATCH_NORMALIZATION_TRAINING_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.inputs.push_back({"MeanTensor", 1, true});
    bindPoints.inputs.push_back({"VarianceTensor", 1, true});
    bindPoints.inputs.push_back({"ScaleTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputScaleGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputBiasGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMeanVarianceNormalizationOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->ScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ScaleTensor", allocator, false);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->CrossChannel = ParseBoolField(value, "CrossChannel", true) ? 1 : 0;
    desc->NormalizeVariance = ParseBoolField(value, "NormalizeVariance", true) ? 1 : 0;
    desc->Epsilon = ParseFloat32Field(value, "Epsilon", true);
    desc->FusedActivation = ParseDmlOperatorDescField(value, "FusedActivation", true, allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"ScaleTensor", 1, false});
    bindPoints.inputs.push_back({"BiasTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlLocalResponseNormalizationOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->CrossChannel = ParseBoolField(value, "CrossChannel", true) ? 1 : 0;
    desc->LocalSize = ParseUInt32Field(value, "LocalSize", true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    desc->Beta = ParseFloat32Field(value, "Beta", true);
    desc->Bias = ParseFloat32Field(value, "Bias", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlLocalResponseNormalizationGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->CrossChannel = ParseBoolField(value, "CrossChannel", true) ? 1 : 0;
    desc->LocalSize = ParseUInt32Field(value, "LocalSize", true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    desc->Beta = ParseFloat32Field(value, "Beta", true);
    desc->Bias = ParseFloat32Field(value, "Bias", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlLpNormalizationOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_LP_NORMALIZATION_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    desc->Epsilon = ParseFloat32Field(value, "Epsilon", true);
    desc->P = ParseUInt32Field(value, "P", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_LP_NORMALIZATION;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_LP_NORMALIZATION_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlRnnOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_RNN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->WeightTensor = fused ? nullptr : ParseDmlTensorDescField(value, "WeightTensor", allocator, true);
    desc->RecurrenceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "RecurrenceTensor", allocator, true);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, false);
    desc->HiddenInitTensor = fused ? nullptr : ParseDmlTensorDescField(value, "HiddenInitTensor", allocator, false);
    desc->SequenceLengthsTensor = fused ? nullptr : ParseDmlTensorDescField(value, "SequenceLengthsTensor", allocator, false);
    desc->OutputSequenceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputSequenceTensor", allocator, false);
    desc->OutputSingleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputSingleTensor", allocator, false);
    desc->ActivationDescCount = ParseUInt32Field(value, "ActivationDescCount", true);
    desc->ActivationDescs = AsPointer(ParseDmlOperatorDescArrayField(value, "ActivationDescs", true, allocator, true));
    desc->Direction = ParseDmlRecurrentNetworkDirectionField(value, "Direction", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_RNN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_RNN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"WeightTensor", 1, true});
    bindPoints.inputs.push_back({"RecurrenceTensor", 1, true});
    bindPoints.inputs.push_back({"BiasTensor", 1, false});
    bindPoints.inputs.push_back({"HiddenInitTensor", 1, false});
    bindPoints.inputs.push_back({"SequenceLengthsTensor", 1, false});
    bindPoints.outputs.push_back({"OutputSequenceTensor", 1, false});
    bindPoints.outputs.push_back({"OutputSingleTensor", 1, false});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlLstmOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_LSTM_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->WeightTensor = fused ? nullptr : ParseDmlTensorDescField(value, "WeightTensor", allocator, true);
    desc->RecurrenceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "RecurrenceTensor", allocator, true);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, false);
    desc->HiddenInitTensor = fused ? nullptr : ParseDmlTensorDescField(value, "HiddenInitTensor", allocator, false);
    desc->CellMemInitTensor = fused ? nullptr : ParseDmlTensorDescField(value, "CellMemInitTensor", allocator, false);
    desc->SequenceLengthsTensor = fused ? nullptr : ParseDmlTensorDescField(value, "SequenceLengthsTensor", allocator, false);
    desc->PeepholeTensor = fused ? nullptr : ParseDmlTensorDescField(value, "PeepholeTensor", allocator, false);
    desc->OutputSequenceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputSequenceTensor", allocator, false);
    desc->OutputSingleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputSingleTensor", allocator, false);
    desc->OutputCellSingleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputCellSingleTensor", allocator, false);
    desc->ActivationDescCount = ParseUInt32Field(value, "ActivationDescCount", true);
    desc->ActivationDescs = AsPointer(ParseDmlOperatorDescArrayField(value, "ActivationDescs", true, allocator, true));
    desc->Direction = ParseDmlRecurrentNetworkDirectionField(value, "Direction", true, {});
    desc->ClipThreshold = ParseFloat32Field(value, "ClipThreshold", true);
    desc->UseClipThreshold = ParseBoolField(value, "UseClipThreshold", true) ? 1 : 0;
    desc->CoupleInputForget = ParseBoolField(value, "CoupleInputForget", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_LSTM;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_LSTM_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"WeightTensor", 1, true});
    bindPoints.inputs.push_back({"RecurrenceTensor", 1, true});
    bindPoints.inputs.push_back({"BiasTensor", 1, false});
    bindPoints.inputs.push_back({"HiddenInitTensor", 1, false});
    bindPoints.inputs.push_back({"CellMemInitTensor", 1, false});
    bindPoints.inputs.push_back({"SequenceLengthsTensor", 1, false});
    bindPoints.inputs.push_back({"PeepholeTensor", 1, false});
    bindPoints.outputs.push_back({"OutputSequenceTensor", 1, false});
    bindPoints.outputs.push_back({"OutputSingleTensor", 1, false});
    bindPoints.outputs.push_back({"OutputCellSingleTensor", 1, false});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlGruOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_GRU_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->WeightTensor = fused ? nullptr : ParseDmlTensorDescField(value, "WeightTensor", allocator, true);
    desc->RecurrenceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "RecurrenceTensor", allocator, true);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, false);
    desc->HiddenInitTensor = fused ? nullptr : ParseDmlTensorDescField(value, "HiddenInitTensor", allocator, false);
    desc->SequenceLengthsTensor = fused ? nullptr : ParseDmlTensorDescField(value, "SequenceLengthsTensor", allocator, false);
    desc->OutputSequenceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputSequenceTensor", allocator, false);
    desc->OutputSingleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputSingleTensor", allocator, false);
    desc->ActivationDescCount = ParseUInt32Field(value, "ActivationDescCount", true);
    desc->ActivationDescs = AsPointer(ParseDmlOperatorDescArrayField(value, "ActivationDescs", true, allocator, true));
    desc->Direction = ParseDmlRecurrentNetworkDirectionField(value, "Direction", true, {});
    desc->LinearBeforeReset = ParseBoolField(value, "LinearBeforeReset", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_GRU;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_GRU_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"WeightTensor", 1, true});
    bindPoints.inputs.push_back({"RecurrenceTensor", 1, true});
    bindPoints.inputs.push_back({"BiasTensor", 1, false});
    bindPoints.inputs.push_back({"HiddenInitTensor", 1, false});
    bindPoints.inputs.push_back({"SequenceLengthsTensor", 1, false});
    bindPoints.outputs.push_back({"OutputSequenceTensor", 1, false});
    bindPoints.outputs.push_back({"OutputSingleTensor", 1, false});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseSignOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_SIGN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_SIGN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_SIGN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseIsNanOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_IS_NAN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_IS_NAN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_IS_NAN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseNegateOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_NEGATE_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_NEGATE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_NEGATE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseErfOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ERF_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ERF;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ERF_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseSinhOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_SINH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_SINH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_SINH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseCoshOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_COSH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_COSH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_COSH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseTanhOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_TANH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_TANH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_TANH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAsinhOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ASINH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ASINH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ASINH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAcoshOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ACOSH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ACOSH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ACOSH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAtanhOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ATANH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ScaleBias = ParseDmlScaleBiasField(value, "ScaleBias", allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ATANH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ATANH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseIfOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_IF_OPERATOR_DESC>();
    desc->ConditionTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ConditionTensor", allocator, true);
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_IF;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_IF_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ConditionTensor", 1, true});
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseAdd1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ADD1_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->FusedActivation = ParseDmlOperatorDescField(value, "FusedActivation", true, allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ADD1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ADD1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMaxUnpoolingOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MAX_UNPOOLING_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->IndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "IndicesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MAX_UNPOOLING;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MAX_UNPOOLING_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"IndicesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlDiagonalMatrixOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_DIAGONAL_MATRIX_OPERATOR_DESC>();
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Offset = ParseInt32Field(value, "Offset", true);
    desc->Value = ParseFloat32Field(value, "Value", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_DIAGONAL_MATRIX;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_DIAGONAL_MATRIX_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlScatterOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_SCATTER_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->IndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "IndicesTensor", allocator, true);
    desc->UpdatesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "UpdatesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_SCATTER;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_SCATTER_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"IndicesTensor", 1, true});
    bindPoints.inputs.push_back({"UpdatesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlOneHotOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ONE_HOT_OPERATOR_DESC>();
    desc->IndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "IndicesTensor", allocator, true);
    desc->ValuesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ValuesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ONE_HOT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ONE_HOT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"IndicesTensor", 1, true});
    bindPoints.inputs.push_back({"ValuesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlResampleOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_RESAMPLE_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->InterpolationMode = ParseDmlInterpolationModeField(value, "InterpolationMode", true, {});
    desc->ScaleCount = ParseUInt32Field(value, "ScaleCount", true);
    desc->Scales = AsPointer(ParseFloat32ArrayField(value, "Scales", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_RESAMPLE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_RESAMPLE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseBitShiftLeftOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_LEFT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseBitShiftRightOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_RIGHT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseRoundOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_ROUND_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->RoundingMode = ParseDmlRoundingModeField(value, "RoundingMode", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_ROUND;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_ROUND_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseIsInfinityOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->InfinityMode = ParseDmlIsInfinityModeField(value, "InfinityMode", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_IS_INFINITY;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseModulusTruncateOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_MODULUS_TRUNCATE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseModulusFloorOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_MODULUS_FLOOR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlFillValueConstantOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_FILL_VALUE_CONSTANT_OPERATOR_DESC>();
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ValueDataType = ParseDmlTensorDataTypeField(value, "ValueDataType", true, {});
    desc->Value = *ParseDmlScalarUnionField(value, "Value", "ValueDataType", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_FILL_VALUE_CONSTANT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_FILL_VALUE_CONSTANT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlFillValueSequenceOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_FILL_VALUE_SEQUENCE_OPERATOR_DESC>();
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ValueDataType = ParseDmlTensorDataTypeField(value, "ValueDataType", true, {});
    desc->ValueStart = *ParseDmlScalarUnionField(value, "ValueStart", "ValueDataType", allocator, true);
    desc->ValueDelta = *ParseDmlScalarUnionField(value, "ValueDelta", "ValueDataType", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_FILL_VALUE_SEQUENCE;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_FILL_VALUE_SEQUENCE_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlCumulativeSummationOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_CUMULATIVE_SUMMATION_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    desc->AxisDirection = ParseDmlAxisDirectionField(value, "AxisDirection", true, {});
    desc->HasExclusiveSum = ParseBoolField(value, "HasExclusiveSum", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_CUMULATIVE_SUMMATION;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_CUMULATIVE_SUMMATION_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlCumulativeProductOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_CUMULATIVE_PRODUCT_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    desc->AxisDirection = ParseDmlAxisDirectionField(value, "AxisDirection", true, {});
    desc->HasExclusiveProduct = ParseBoolField(value, "HasExclusiveProduct", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_CUMULATIVE_PRODUCT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_CUMULATIVE_PRODUCT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlReverseSubsequencesOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_REVERSE_SUBSEQUENCES_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->SequenceLengthsTensor = fused ? nullptr : ParseDmlTensorDescField(value, "SequenceLengthsTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_REVERSE_SUBSEQUENCES;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_REVERSE_SUBSEQUENCES_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"SequenceLengthsTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlGatherElementsOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_GATHER_ELEMENTS_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->IndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "IndicesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_GATHER_ELEMENTS;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_GATHER_ELEMENTS_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"IndicesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlGatherNdOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_GATHER_ND_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->IndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "IndicesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->InputDimensionCount = ParseUInt32Field(value, "InputDimensionCount", true);
    desc->IndicesDimensionCount = ParseUInt32Field(value, "IndicesDimensionCount", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_GATHER_ND;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_GATHER_ND_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"IndicesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlScatterNdOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_SCATTER_ND_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->IndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "IndicesTensor", allocator, true);
    desc->UpdatesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "UpdatesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->InputDimensionCount = ParseUInt32Field(value, "InputDimensionCount", true);
    desc->IndicesDimensionCount = ParseUInt32Field(value, "IndicesDimensionCount", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_SCATTER_ND;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_SCATTER_ND_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"IndicesTensor", 1, true});
    bindPoints.inputs.push_back({"UpdatesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMaxPooling2OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MAX_POOLING2_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->OutputIndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputIndicesTensor", allocator, false);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->Dilations = AsPointer(ParseUInt32ArrayField(value, "Dilations", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MAX_POOLING2;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MAX_POOLING2_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputIndicesTensor", 1, false});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlSlice1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_SLICE1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->InputWindowOffsets = AsPointer(ParseUInt32ArrayField(value, "InputWindowOffsets", allocator, true));
    desc->InputWindowSizes = AsPointer(ParseUInt32ArrayField(value, "InputWindowSizes", allocator, true));
    desc->InputWindowStrides = AsPointer(ParseInt32ArrayField(value, "InputWindowStrides", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_SLICE1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_SLICE1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlTopK1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_TOP_K1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputValueTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputValueTensor", allocator, true);
    desc->OutputIndexTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputIndexTensor", allocator, true);
    desc->Axis = ParseUInt32Field(value, "Axis", true);
    desc->K = ParseUInt32Field(value, "K", true);
    desc->AxisDirection = ParseDmlAxisDirectionField(value, "AxisDirection", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_TOP_K1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_TOP_K1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputValueTensor", 1, true});
    bindPoints.outputs.push_back({"OutputIndexTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlDepthToSpace1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_DEPTH_TO_SPACE1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->BlockSize = ParseUInt32Field(value, "BlockSize", true);
    desc->Order = ParseDmlDepthSpaceOrderField(value, "Order", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_DEPTH_TO_SPACE1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_DEPTH_TO_SPACE1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlSpaceToDepth1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_SPACE_TO_DEPTH1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->BlockSize = ParseUInt32Field(value, "BlockSize", true);
    desc->Order = ParseDmlDepthSpaceOrderField(value, "Order", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_SPACE_TO_DEPTH1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_SPACE_TO_DEPTH1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMeanVarianceNormalization1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->ScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ScaleTensor", allocator, false);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->AxisCount = ParseUInt32Field(value, "AxisCount", true);
    desc->Axes = AsPointer(ParseUInt32ArrayField(value, "Axes", allocator, true));
    desc->NormalizeVariance = ParseBoolField(value, "NormalizeVariance", true) ? 1 : 0;
    desc->Epsilon = ParseFloat32Field(value, "Epsilon", true);
    desc->FusedActivation = ParseDmlOperatorDescField(value, "FusedActivation", true, allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"ScaleTensor", 1, false});
    bindPoints.inputs.push_back({"BiasTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlResample1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_RESAMPLE1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->InterpolationMode = ParseDmlInterpolationModeField(value, "InterpolationMode", true, {});
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Scales = AsPointer(ParseFloat32ArrayField(value, "Scales", allocator, true));
    desc->InputPixelOffsets = AsPointer(ParseFloat32ArrayField(value, "InputPixelOffsets", allocator, true));
    desc->OutputPixelOffsets = AsPointer(ParseFloat32ArrayField(value, "OutputPixelOffsets", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_RESAMPLE1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_RESAMPLE1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMatrixMultiplyIntegerOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->AZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "AZeroPointTensor", allocator, false);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->BZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BZeroPointTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MATRIX_MULTIPLY_INTEGER;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"AZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.inputs.push_back({"BZeroPointTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlQuantizedLinearMatrixMultiplyOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->AScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "AScaleTensor", allocator, true);
    desc->AZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "AZeroPointTensor", allocator, false);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->BScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BScaleTensor", allocator, true);
    desc->BZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BZeroPointTensor", allocator, false);
    desc->OutputScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputScaleTensor", allocator, true);
    desc->OutputZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputZeroPointTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_QUANTIZED_LINEAR_MATRIX_MULTIPLY;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"AScaleTensor", 1, true});
    bindPoints.inputs.push_back({"AZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.inputs.push_back({"BScaleTensor", 1, true});
    bindPoints.inputs.push_back({"BZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"OutputScaleTensor", 1, true});
    bindPoints.inputs.push_back({"OutputZeroPointTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlConvolutionIntegerOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_CONVOLUTION_INTEGER_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputZeroPointTensor", allocator, false);
    desc->FilterTensor = fused ? nullptr : ParseDmlTensorDescField(value, "FilterTensor", allocator, true);
    desc->FilterZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "FilterZeroPointTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->Dilations = AsPointer(ParseUInt32ArrayField(value, "Dilations", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->GroupCount = ParseUInt32Field(value, "GroupCount", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_CONVOLUTION_INTEGER;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_CONVOLUTION_INTEGER_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"FilterTensor", 1, true});
    bindPoints.inputs.push_back({"FilterZeroPointTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlQuantizedLinearConvolutionOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputScaleTensor", allocator, true);
    desc->InputZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputZeroPointTensor", allocator, false);
    desc->FilterTensor = fused ? nullptr : ParseDmlTensorDescField(value, "FilterTensor", allocator, true);
    desc->FilterScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "FilterScaleTensor", allocator, true);
    desc->FilterZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "FilterZeroPointTensor", allocator, false);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, false);
    desc->OutputScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputScaleTensor", allocator, true);
    desc->OutputZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputZeroPointTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->Dilations = AsPointer(ParseUInt32ArrayField(value, "Dilations", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->GroupCount = ParseUInt32Field(value, "GroupCount", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_QUANTIZED_LINEAR_CONVOLUTION;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputScaleTensor", 1, true});
    bindPoints.inputs.push_back({"InputZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"FilterTensor", 1, true});
    bindPoints.inputs.push_back({"FilterScaleTensor", 1, true});
    bindPoints.inputs.push_back({"FilterZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"BiasTensor", 1, false});
    bindPoints.inputs.push_back({"OutputScaleTensor", 1, true});
    bindPoints.inputs.push_back({"OutputZeroPointTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseBitAndOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_BIT_AND_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_BIT_AND;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_BIT_AND_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseBitOrOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_BIT_OR_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_BIT_OR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_BIT_OR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseBitXorOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_BIT_XOR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseBitNotOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_BIT_NOT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseBitCountOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_BIT_COUNT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationReluGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_RELU_GRAD_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_RELU_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_RELU_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlAveragePoolingGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_AVERAGE_POOLING_GRAD_OPERATOR_DESC>();
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->IncludePadding = ParseBoolField(value, "IncludePadding", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_AVERAGE_POOLING_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_AVERAGE_POOLING_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMaxPoolingGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MAX_POOLING_GRAD_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->Dilations = AsPointer(ParseUInt32ArrayField(value, "Dilations", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MAX_POOLING_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MAX_POOLING_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlRandomGeneratorOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_RANDOM_GENERATOR_OPERATOR_DESC>();
    desc->InputStateTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputStateTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->OutputStateTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputStateTensor", allocator, false);
    desc->Type = ParseDmlRandomGeneratorTypeField(value, "Type", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_RANDOM_GENERATOR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_RANDOM_GENERATOR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputStateTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputStateTensor", 1, false});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlNonzeroCoordinatesOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_NONZERO_COORDINATES_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputCountTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputCountTensor", allocator, true);
    desc->OutputCoordinatesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputCoordinatesTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_NONZERO_COORDINATES;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_NONZERO_COORDINATES_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputCountTensor", 1, true});
    bindPoints.outputs.push_back({"OutputCoordinatesTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlResampleGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_RESAMPLE_GRAD_OPERATOR_DESC>();
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->InterpolationMode = ParseDmlInterpolationModeField(value, "InterpolationMode", true, {});
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Scales = AsPointer(ParseFloat32ArrayField(value, "Scales", allocator, true));
    desc->InputPixelOffsets = AsPointer(ParseFloat32ArrayField(value, "InputPixelOffsets", allocator, true));
    desc->OutputPixelOffsets = AsPointer(ParseFloat32ArrayField(value, "OutputPixelOffsets", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_RESAMPLE_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_RESAMPLE_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlSliceGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_SLICE_GRAD_OPERATOR_DESC>();
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->InputWindowOffsets = AsPointer(ParseUInt32ArrayField(value, "InputWindowOffsets", allocator, true));
    desc->InputWindowSizes = AsPointer(ParseUInt32ArrayField(value, "InputWindowSizes", allocator, true));
    desc->InputWindowStrides = AsPointer(ParseInt32ArrayField(value, "InputWindowStrides", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_SLICE_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_SLICE_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlAdamOptimizerOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ADAM_OPTIMIZER_OPERATOR_DESC>();
    desc->InputParametersTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputParametersTensor", allocator, true);
    desc->InputFirstMomentTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputFirstMomentTensor", allocator, true);
    desc->InputSecondMomentTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputSecondMomentTensor", allocator, true);
    desc->GradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "GradientTensor", allocator, true);
    desc->TrainingStepTensor = fused ? nullptr : ParseDmlTensorDescField(value, "TrainingStepTensor", allocator, true);
    desc->OutputParametersTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputParametersTensor", allocator, true);
    desc->OutputFirstMomentTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputFirstMomentTensor", allocator, true);
    desc->OutputSecondMomentTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputSecondMomentTensor", allocator, true);
    desc->LearningRate = ParseFloat32Field(value, "LearningRate", true);
    desc->Beta1 = ParseFloat32Field(value, "Beta1", true);
    desc->Beta2 = ParseFloat32Field(value, "Beta2", true);
    desc->Epsilon = ParseFloat32Field(value, "Epsilon", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ADAM_OPTIMIZER;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ADAM_OPTIMIZER_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputParametersTensor", 1, true});
    bindPoints.inputs.push_back({"InputFirstMomentTensor", 1, true});
    bindPoints.inputs.push_back({"InputSecondMomentTensor", 1, true});
    bindPoints.inputs.push_back({"GradientTensor", 1, true});
    bindPoints.inputs.push_back({"TrainingStepTensor", 1, true});
    bindPoints.outputs.push_back({"OutputParametersTensor", 1, true});
    bindPoints.outputs.push_back({"OutputFirstMomentTensor", 1, true});
    bindPoints.outputs.push_back({"OutputSecondMomentTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlRoiAlignOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ROI_ALIGN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->ROITensor = fused ? nullptr : ParseDmlTensorDescField(value, "ROITensor", allocator, true);
    desc->BatchIndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BatchIndicesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ReductionFunction = ParseDmlReduceFunctionField(value, "ReductionFunction", true, {});
    desc->InterpolationMode = ParseDmlInterpolationModeField(value, "InterpolationMode", true, {});
    desc->SpatialScaleX = ParseFloat32Field(value, "SpatialScaleX", true);
    desc->SpatialScaleY = ParseFloat32Field(value, "SpatialScaleY", true);
    desc->OutOfBoundsInputValue = ParseFloat32Field(value, "OutOfBoundsInputValue", true);
    desc->MinimumSamplesPerOutput = ParseUInt32Field(value, "MinimumSamplesPerOutput", true);
    desc->MaximumSamplesPerOutput = ParseUInt32Field(value, "MaximumSamplesPerOutput", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ROI_ALIGN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ROI_ALIGN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"ROITensor", 1, true});
    bindPoints.inputs.push_back({"BatchIndicesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlRoiAlign1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ROI_ALIGN1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->ROITensor = fused ? nullptr : ParseDmlTensorDescField(value, "ROITensor", allocator, true);
    desc->BatchIndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BatchIndicesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ReductionFunction = ParseDmlReduceFunctionField(value, "ReductionFunction", true, {});
    desc->InterpolationMode = ParseDmlInterpolationModeField(value, "InterpolationMode", true, {});
    desc->SpatialScaleX = ParseFloat32Field(value, "SpatialScaleX", true);
    desc->SpatialScaleY = ParseFloat32Field(value, "SpatialScaleY", true);
    desc->InputPixelOffset = ParseFloat32Field(value, "InputPixelOffset", true);
    desc->OutputPixelOffset = ParseFloat32Field(value, "OutputPixelOffset", true);
    desc->OutOfBoundsInputValue = ParseFloat32Field(value, "OutOfBoundsInputValue", true);
    desc->MinimumSamplesPerOutput = ParseUInt32Field(value, "MinimumSamplesPerOutput", true);
    desc->MaximumSamplesPerOutput = ParseUInt32Field(value, "MaximumSamplesPerOutput", true);
    desc->AlignRegionsToCorners = ParseBoolField(value, "AlignRegionsToCorners", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ROI_ALIGN1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ROI_ALIGN1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"ROITensor", 1, true});
    bindPoints.inputs.push_back({"BatchIndicesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlGatherNd1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_GATHER_ND1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->IndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "IndicesTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->InputDimensionCount = ParseUInt32Field(value, "InputDimensionCount", true);
    desc->IndicesDimensionCount = ParseUInt32Field(value, "IndicesDimensionCount", true);
    desc->BatchDimensionCount = ParseUInt32Field(value, "BatchDimensionCount", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_GATHER_ND1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_GATHER_ND1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"IndicesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlDynamicQuantizeLinearOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->OutputScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputScaleTensor", allocator, true);
    desc->OutputZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputZeroPointTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_DYNAMIC_QUANTIZE_LINEAR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputScaleTensor", 1, true});
    bindPoints.outputs.push_back({"OutputZeroPointTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlElementWiseQuantizedLinearAddOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->AScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "AScaleTensor", allocator, true);
    desc->AZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "AZeroPointTensor", allocator, false);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->BScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BScaleTensor", allocator, true);
    desc->BZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BZeroPointTensor", allocator, false);
    desc->OutputScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputScaleTensor", allocator, true);
    desc->OutputZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputZeroPointTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ELEMENT_WISE_QUANTIZED_LINEAR_ADD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"AScaleTensor", 1, true});
    bindPoints.inputs.push_back({"AZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.inputs.push_back({"BScaleTensor", 1, true});
    bindPoints.inputs.push_back({"BZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"OutputScaleTensor", 1, true});
    bindPoints.inputs.push_back({"OutputZeroPointTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlRoiAlignGradOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ROI_ALIGN_GRAD_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, false);
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->ROITensor = fused ? nullptr : ParseDmlTensorDescField(value, "ROITensor", allocator, true);
    desc->BatchIndicesTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BatchIndicesTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, false);
    desc->OutputROIGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputROIGradientTensor", allocator, false);
    desc->ReductionFunction = ParseDmlReduceFunctionField(value, "ReductionFunction", true, {});
    desc->InterpolationMode = ParseDmlInterpolationModeField(value, "InterpolationMode", true, {});
    desc->SpatialScaleX = ParseFloat32Field(value, "SpatialScaleX", true);
    desc->SpatialScaleY = ParseFloat32Field(value, "SpatialScaleY", true);
    desc->InputPixelOffset = ParseFloat32Field(value, "InputPixelOffset", true);
    desc->OutputPixelOffset = ParseFloat32Field(value, "OutputPixelOffset", true);
    desc->MinimumSamplesPerOutput = ParseUInt32Field(value, "MinimumSamplesPerOutput", true);
    desc->MaximumSamplesPerOutput = ParseUInt32Field(value, "MaximumSamplesPerOutput", true);
    desc->AlignRegionsToCorners = ParseBoolField(value, "AlignRegionsToCorners", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ROI_ALIGN_GRAD;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ROI_ALIGN_GRAD_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, false});
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.inputs.push_back({"ROITensor", 1, true});
    bindPoints.inputs.push_back({"BatchIndicesTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, false});
    bindPoints.outputs.push_back({"OutputROIGradientTensor", 1, false});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlBatchNormalizationTrainingOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_BATCH_NORMALIZATION_TRAINING_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->ScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ScaleTensor", allocator, true);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, true);
    desc->FusedAddTensor = fused ? nullptr : ParseDmlTensorDescField(value, "FusedAddTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->OutputMeanTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputMeanTensor", allocator, true);
    desc->OutputVarianceTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputVarianceTensor", allocator, true);
    desc->Epsilon = ParseFloat32Field(value, "Epsilon", true);
    desc->FusedActivation = ParseDmlOperatorDescField(value, "FusedActivation", true, allocator, false);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_BATCH_NORMALIZATION_TRAINING;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_BATCH_NORMALIZATION_TRAINING_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"ScaleTensor", 1, true});
    bindPoints.inputs.push_back({"BiasTensor", 1, true});
    bindPoints.inputs.push_back({"FusedAddTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputMeanTensor", 1, true});
    bindPoints.outputs.push_back({"OutputVarianceTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlResample2OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_RESAMPLE2_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->InterpolationMode = ParseDmlInterpolationModeField(value, "InterpolationMode", true, {});
    desc->RoundingDirection = ParseDmlAxisDirectionField(value, "RoundingDirection", true, {});
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Scales = AsPointer(ParseFloat32ArrayField(value, "Scales", allocator, true));
    desc->InputPixelOffsets = AsPointer(ParseFloat32ArrayField(value, "InputPixelOffsets", allocator, true));
    desc->OutputPixelOffsets = AsPointer(ParseFloat32ArrayField(value, "OutputPixelOffsets", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_RESAMPLE2;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_RESAMPLE2_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlResampleGrad1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_RESAMPLE_GRAD1_OPERATOR_DESC>();
    desc->InputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputGradientTensor", allocator, true);
    desc->OutputGradientTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputGradientTensor", allocator, true);
    desc->InterpolationMode = ParseDmlInterpolationModeField(value, "InterpolationMode", true, {});
    desc->RoundingDirection = ParseDmlAxisDirectionField(value, "RoundingDirection", true, {});
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Scales = AsPointer(ParseFloat32ArrayField(value, "Scales", allocator, true));
    desc->InputPixelOffsets = AsPointer(ParseFloat32ArrayField(value, "InputPixelOffsets", allocator, true));
    desc->OutputPixelOffsets = AsPointer(ParseFloat32ArrayField(value, "OutputPixelOffsets", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_RESAMPLE_GRAD1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_RESAMPLE_GRAD1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputGradientTensor", 1, true});
    bindPoints.outputs.push_back({"OutputGradientTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlDiagonalMatrix1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_DIAGONAL_MATRIX1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->ValueDataType = ParseDmlTensorDataTypeField(value, "ValueDataType", true, {});
    desc->Value = *ParseDmlScalarUnionField(value, "Value", "ValueDataType", allocator, true);
    desc->DiagonalFillBegin = ParseInt32Field(value, "DiagonalFillBegin", true);
    desc->DiagonalFillEnd = ParseInt32Field(value, "DiagonalFillEnd", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_DIAGONAL_MATRIX1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_DIAGONAL_MATRIX1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMultiheadAttentionOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MULTIHEAD_ATTENTION_OPERATOR_DESC>();
    desc->QueryTensor = fused ? nullptr : ParseDmlTensorDescField(value, "QueryTensor", allocator, false);
    desc->KeyTensor = fused ? nullptr : ParseDmlTensorDescField(value, "KeyTensor", allocator, false);
    desc->ValueTensor = fused ? nullptr : ParseDmlTensorDescField(value, "ValueTensor", allocator, false);
    desc->StackedQueryKeyTensor = fused ? nullptr : ParseDmlTensorDescField(value, "StackedQueryKeyTensor", allocator, false);
    desc->StackedKeyValueTensor = fused ? nullptr : ParseDmlTensorDescField(value, "StackedKeyValueTensor", allocator, false);
    desc->StackedQueryKeyValueTensor = fused ? nullptr : ParseDmlTensorDescField(value, "StackedQueryKeyValueTensor", allocator, false);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, false);
    desc->MaskTensor = fused ? nullptr : ParseDmlTensorDescField(value, "MaskTensor", allocator, false);
    desc->RelativePositionBiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "RelativePositionBiasTensor", allocator, false);
    desc->PastKeyTensor = fused ? nullptr : ParseDmlTensorDescField(value, "PastKeyTensor", allocator, false);
    desc->PastValueTensor = fused ? nullptr : ParseDmlTensorDescField(value, "PastValueTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->OutputPresentKeyTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputPresentKeyTensor", allocator, false);
    desc->OutputPresentValueTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputPresentValueTensor", allocator, false);
    desc->Scale = ParseFloat32Field(value, "Scale", true);
    desc->MaskFilterValue = ParseFloat32Field(value, "MaskFilterValue", true);
    desc->HeadCount = ParseUInt32Field(value, "HeadCount", true);
    desc->MaskType = ParseDmlMultiheadAttentionMaskTypeField(value, "MaskType", true, {});
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MULTIHEAD_ATTENTION;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MULTIHEAD_ATTENTION_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"QueryTensor", 1, false});
    bindPoints.inputs.push_back({"KeyTensor", 1, false});
    bindPoints.inputs.push_back({"ValueTensor", 1, false});
    bindPoints.inputs.push_back({"StackedQueryKeyTensor", 1, false});
    bindPoints.inputs.push_back({"StackedKeyValueTensor", 1, false});
    bindPoints.inputs.push_back({"StackedQueryKeyValueTensor", 1, false});
    bindPoints.inputs.push_back({"BiasTensor", 1, false});
    bindPoints.inputs.push_back({"MaskTensor", 1, false});
    bindPoints.inputs.push_back({"RelativePositionBiasTensor", 1, false});
    bindPoints.inputs.push_back({"PastKeyTensor", 1, false});
    bindPoints.inputs.push_back({"PastValueTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputPresentKeyTensor", 1, false});
    bindPoints.outputs.push_back({"OutputPresentValueTensor", 1, false});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlQuantizedLinearAveragePoolingOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_QUANTIZED_LINEAR_AVERAGE_POOLING_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->InputScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputScaleTensor", allocator, true);
    desc->InputZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputZeroPointTensor", allocator, false);
    desc->OutputScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputScaleTensor", allocator, true);
    desc->OutputZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputZeroPointTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->DimensionCount = ParseUInt32Field(value, "DimensionCount", true);
    desc->Strides = AsPointer(ParseUInt32ArrayField(value, "Strides", allocator, true));
    desc->WindowSize = AsPointer(ParseUInt32ArrayField(value, "WindowSize", allocator, true));
    desc->StartPadding = AsPointer(ParseUInt32ArrayField(value, "StartPadding", allocator, true));
    desc->EndPadding = AsPointer(ParseUInt32ArrayField(value, "EndPadding", allocator, true));
    desc->Dilations = AsPointer(ParseUInt32ArrayField(value, "Dilations", allocator, true));
    desc->IncludePadding = ParseBoolField(value, "IncludePadding", true) ? 1 : 0;
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_QUANTIZED_LINEAR_AVERAGE_POOLING;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_QUANTIZED_LINEAR_AVERAGE_POOLING_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"InputScaleTensor", 1, true});
    bindPoints.inputs.push_back({"InputZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"OutputScaleTensor", 1, true});
    bindPoints.inputs.push_back({"OutputZeroPointTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlMatrixMultiplyIntegerToFloatOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_MATRIX_MULTIPLY_INTEGER_TO_FLOAT_OPERATOR_DESC>();
    desc->ATensor = fused ? nullptr : ParseDmlTensorDescField(value, "ATensor", allocator, true);
    desc->AScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "AScaleTensor", allocator, true);
    desc->AZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "AZeroPointTensor", allocator, false);
    desc->BTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BTensor", allocator, true);
    desc->BScaleTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BScaleTensor", allocator, true);
    desc->BZeroPointTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BZeroPointTensor", allocator, false);
    desc->BiasTensor = fused ? nullptr : ParseDmlTensorDescField(value, "BiasTensor", allocator, false);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_MATRIX_MULTIPLY_INTEGER_TO_FLOAT;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_MATRIX_MULTIPLY_INTEGER_TO_FLOAT_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"ATensor", 1, true});
    bindPoints.inputs.push_back({"AScaleTensor", 1, true});
    bindPoints.inputs.push_back({"AZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"BTensor", 1, true});
    bindPoints.inputs.push_back({"BScaleTensor", 1, true});
    bindPoints.inputs.push_back({"BZeroPointTensor", 1, false});
    bindPoints.inputs.push_back({"BiasTensor", 1, false});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationEluOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_ELU_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_ELU;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_ELU_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationCeluOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_CELU_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_CELU;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_CELU_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationHardmaxOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_HARDMAX_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_HARDMAX;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_HARDMAX_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationHardmax1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_HARDMAX1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->AxisCount = ParseUInt32Field(value, "AxisCount", true);
    desc->Axes = AsPointer(ParseUInt32ArrayField(value, "Axes", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_HARDMAX1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_HARDMAX1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationHardSigmoidOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    desc->Beta = ParseFloat32Field(value, "Beta", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_HARD_SIGMOID;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationIdentityOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_IDENTITY_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_IDENTITY;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_IDENTITY_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationLeakyReluOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_LEAKY_RELU;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationLinearOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_LINEAR_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    desc->Beta = ParseFloat32Field(value, "Beta", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_LINEAR;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_LINEAR_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationLogSoftmaxOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_LOG_SOFTMAX;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationLogSoftmax1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_LOG_SOFTMAX1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->AxisCount = ParseUInt32Field(value, "AxisCount", true);
    desc->Axes = AsPointer(ParseUInt32ArrayField(value, "Axes", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_LOG_SOFTMAX1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_LOG_SOFTMAX1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationParameterizedReluOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->SlopeTensor = fused ? nullptr : ParseDmlTensorDescField(value, "SlopeTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_PARAMETERIZED_RELU;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.inputs.push_back({"SlopeTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationParametricSoftplusOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    desc->Beta = ParseFloat32Field(value, "Beta", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_PARAMETRIC_SOFTPLUS;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationReluOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_RELU_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_RELU;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_RELU_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationScaledEluOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_SCALED_ELU_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    desc->Gamma = ParseFloat32Field(value, "Gamma", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_SCALED_ELU;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_SCALED_ELU_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationScaledTanhOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_SCALED_TANH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    desc->Beta = ParseFloat32Field(value, "Beta", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_SCALED_TANH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_SCALED_TANH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationSigmoidOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_SIGMOID_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_SIGMOID;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_SIGMOID_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationSoftmaxOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_SOFTMAX_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_SOFTMAX;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_SOFTMAX_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationSoftmax1OperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_SOFTMAX1_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->AxisCount = ParseUInt32Field(value, "AxisCount", true);
    desc->Axes = AsPointer(ParseUInt32ArrayField(value, "Axes", allocator, true));
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_SOFTMAX1;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_SOFTMAX1_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationSoftplusOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_SOFTPLUS_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Steepness = ParseFloat32Field(value, "Steepness", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_SOFTPLUS;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_SOFTPLUS_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationSoftsignOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_SOFTSIGN_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_SOFTSIGN;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_SOFTSIGN_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationTanhOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_TANH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_TANH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_TANH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationThresholdedReluOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_THRESHOLDED_RELU;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationShrinkOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_SHRINK_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Bias = ParseFloat32Field(value, "Bias", true);
    desc->Threshold = ParseFloat32Field(value, "Threshold", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_SHRINK;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_SHRINK_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationGeluOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_GELU_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_GELU;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_GELU_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationSwishOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_SWISH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->SigmoidInputScale = ParseFloat32Field(value, "SigmoidInputScale", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_SWISH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_SWISH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlActivationHardSwishOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject()) { throw std::invalid_argument("Expected a valid JSON object."); }
    auto desc = allocator.Allocate<DML_ACTIVATION_HARD_SWISH_OPERATOR_DESC>();
    desc->InputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "InputTensor", allocator, true);
    desc->OutputTensor = fused ? nullptr : ParseDmlTensorDescField(value, "OutputTensor", allocator, true);
    desc->Alpha = ParseFloat32Field(value, "Alpha", true);
    desc->Beta = ParseFloat32Field(value, "Beta", true);
    auto opDesc = allocator.Allocate<DML_OPERATOR_DESC>();
    opDesc->Type = DML_OPERATOR_ACTIVATION_HARD_SWISH;
    opDesc->Desc = desc;
    return opDesc;
}
 
Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_ACTIVATION_HARD_SWISH_OPERATOR_DESC& desc)
{
    Model::DmlDispatchableDesc::BindPoints bindPoints = {};
    bindPoints.inputs.push_back({"InputTensor", 1, true});
    bindPoints.outputs.push_back({"OutputTensor", 1, true});
    return bindPoints;
}
 
DML_OPERATOR_DESC* ParseDmlOperatorDesc(const rapidjson::Value& value, bool fused, BucketAllocator& allocator)
{
    if (!value.IsObject())
    {
        throw std::invalid_argument("Expected a non-null JSON object.");
    }
    auto typeMember = value.FindMember("Type");
    if (typeMember == value.MemberEnd())
    {
        typeMember = value.FindMember("type");
    }
    if (typeMember == value.MemberEnd())
    {
        throw std::invalid_argument("Expected a member 'Type' with the operator type.");
    }
    if (typeMember->value.GetType() != rapidjson::Type::kStringType)
    {
        throw std::invalid_argument("The member 'Type' must be a string.");
    }
    auto type = typeMember->value.GetString();
    auto descMember = value.FindMember("Desc");
    if (descMember == value.MemberEnd())
    {
        descMember = value.FindMember("desc");
    }
    const rapidjson::Value& descValue = descMember != value.MemberEnd() ? descMember->value : value;
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_IDENTITY") || !strcmp(type, "ELEMENT_WISE_IDENTITY")) return ParseDmlElementWiseIdentityOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ABS") || !strcmp(type, "ELEMENT_WISE_ABS")) return ParseDmlElementWiseAbsOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ACOS") || !strcmp(type, "ELEMENT_WISE_ACOS")) return ParseDmlElementWiseAcosOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ADD") || !strcmp(type, "ELEMENT_WISE_ADD")) return ParseDmlElementWiseAddOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ASIN") || !strcmp(type, "ELEMENT_WISE_ASIN")) return ParseDmlElementWiseAsinOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ATAN") || !strcmp(type, "ELEMENT_WISE_ATAN")) return ParseDmlElementWiseAtanOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_CEIL") || !strcmp(type, "ELEMENT_WISE_CEIL")) return ParseDmlElementWiseCeilOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_CLIP") || !strcmp(type, "ELEMENT_WISE_CLIP")) return ParseDmlElementWiseClipOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_CLIP1") || !strcmp(type, "ELEMENT_WISE_CLIP1")) return ParseDmlElementWiseClip1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD") || !strcmp(type, "ELEMENT_WISE_CLIP_GRAD")) return ParseDmlElementWiseClipGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD1") || !strcmp(type, "ELEMENT_WISE_CLIP_GRAD1")) return ParseDmlElementWiseClipGrad1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_COS") || !strcmp(type, "ELEMENT_WISE_COS")) return ParseDmlElementWiseCosOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_DIVIDE") || !strcmp(type, "ELEMENT_WISE_DIVIDE")) return ParseDmlElementWiseDivideOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_EXP") || !strcmp(type, "ELEMENT_WISE_EXP")) return ParseDmlElementWiseExpOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_FLOOR") || !strcmp(type, "ELEMENT_WISE_FLOOR")) return ParseDmlElementWiseFloorOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOG") || !strcmp(type, "ELEMENT_WISE_LOG")) return ParseDmlElementWiseLogOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_AND") || !strcmp(type, "ELEMENT_WISE_LOGICAL_AND")) return ParseDmlElementWiseLogicalAndOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_EQUALS") || !strcmp(type, "ELEMENT_WISE_LOGICAL_EQUALS")) return ParseDmlElementWiseLogicalEqualsOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN") || !strcmp(type, "ELEMENT_WISE_LOGICAL_GREATER_THAN")) return ParseDmlElementWiseLogicalGreaterThanOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN") || !strcmp(type, "ELEMENT_WISE_LOGICAL_LESS_THAN")) return ParseDmlElementWiseLogicalLessThanOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL") || !strcmp(type, "ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL")) return ParseDmlElementWiseLogicalGreaterThanOrEqualOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL") || !strcmp(type, "ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL")) return ParseDmlElementWiseLogicalLessThanOrEqualOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_NOT") || !strcmp(type, "ELEMENT_WISE_LOGICAL_NOT")) return ParseDmlElementWiseLogicalNotOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_OR") || !strcmp(type, "ELEMENT_WISE_LOGICAL_OR")) return ParseDmlElementWiseLogicalOrOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_LOGICAL_XOR") || !strcmp(type, "ELEMENT_WISE_LOGICAL_XOR")) return ParseDmlElementWiseLogicalXorOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_MAX") || !strcmp(type, "ELEMENT_WISE_MAX")) return ParseDmlElementWiseMaxOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_MEAN") || !strcmp(type, "ELEMENT_WISE_MEAN")) return ParseDmlElementWiseMeanOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_MIN") || !strcmp(type, "ELEMENT_WISE_MIN")) return ParseDmlElementWiseMinOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_MULTIPLY") || !strcmp(type, "ELEMENT_WISE_MULTIPLY")) return ParseDmlElementWiseMultiplyOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_POW") || !strcmp(type, "ELEMENT_WISE_POW")) return ParseDmlElementWisePowOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_CONSTANT_POW") || !strcmp(type, "ELEMENT_WISE_CONSTANT_POW")) return ParseDmlElementWiseConstantPowOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_RECIP") || !strcmp(type, "ELEMENT_WISE_RECIP")) return ParseDmlElementWiseRecipOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_SIN") || !strcmp(type, "ELEMENT_WISE_SIN")) return ParseDmlElementWiseSinOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_SQRT") || !strcmp(type, "ELEMENT_WISE_SQRT")) return ParseDmlElementWiseSqrtOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_DIFFERENCE_SQUARE") || !strcmp(type, "ELEMENT_WISE_DIFFERENCE_SQUARE")) return ParseDmlElementWiseDifferenceSquareOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ATAN_YX") || !strcmp(type, "ELEMENT_WISE_ATAN_YX")) return ParseDmlElementWiseAtanYxOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_SUBTRACT") || !strcmp(type, "ELEMENT_WISE_SUBTRACT")) return ParseDmlElementWiseSubtractOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_TAN") || !strcmp(type, "ELEMENT_WISE_TAN")) return ParseDmlElementWiseTanOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_THRESHOLD") || !strcmp(type, "ELEMENT_WISE_THRESHOLD")) return ParseDmlElementWiseThresholdOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_QUANTIZE_LINEAR") || !strcmp(type, "ELEMENT_WISE_QUANTIZE_LINEAR")) return ParseDmlElementWiseQuantizeLinearOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_DEQUANTIZE_LINEAR") || !strcmp(type, "ELEMENT_WISE_DEQUANTIZE_LINEAR")) return ParseDmlElementWiseDequantizeLinearOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_CONVOLUTION") || !strcmp(type, "CONVOLUTION")) return ParseDmlConvolutionOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_GEMM") || !strcmp(type, "GEMM")) return ParseDmlGemmOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_REDUCE") || !strcmp(type, "REDUCE")) return ParseDmlReduceOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ARGMIN") || !strcmp(type, "ARGMIN")) return ParseDmlArgminOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ARGMAX") || !strcmp(type, "ARGMAX")) return ParseDmlArgmaxOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_AVERAGE_POOLING") || !strcmp(type, "AVERAGE_POOLING")) return ParseDmlAveragePoolingOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_AVERAGE_POOLING1") || !strcmp(type, "AVERAGE_POOLING1")) return ParseDmlAveragePooling1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_LP_POOLING") || !strcmp(type, "LP_POOLING")) return ParseDmlLpPoolingOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_LP_POOLING1") || !strcmp(type, "LP_POOLING1")) return ParseDmlLpPooling1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MAX_POOLING") || !strcmp(type, "MAX_POOLING")) return ParseDmlMaxPoolingOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MAX_POOLING1") || !strcmp(type, "MAX_POOLING1")) return ParseDmlMaxPooling1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ROI_POOLING") || !strcmp(type, "ROI_POOLING")) return ParseDmlRoiPoolingOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_SLICE") || !strcmp(type, "SLICE")) return ParseDmlSliceOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_CAST") || !strcmp(type, "CAST")) return ParseDmlCastOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_SPLIT") || !strcmp(type, "SPLIT")) return ParseDmlSplitOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_JOIN") || !strcmp(type, "JOIN")) return ParseDmlJoinOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_PADDING") || !strcmp(type, "PADDING")) return ParseDmlPaddingOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_PADDING1") || !strcmp(type, "PADDING1")) return ParseDmlPadding1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_VALUE_SCALE_2D") || !strcmp(type, "VALUE_SCALE_2D")) return ParseDmlValueScale2dOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_UPSAMPLE_2D") || !strcmp(type, "UPSAMPLE_2D")) return ParseDmlUpsample2dOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_GATHER") || !strcmp(type, "GATHER")) return ParseDmlGatherOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_SPACE_TO_DEPTH") || !strcmp(type, "SPACE_TO_DEPTH")) return ParseDmlSpaceToDepthOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_DEPTH_TO_SPACE") || !strcmp(type, "DEPTH_TO_SPACE")) return ParseDmlDepthToSpaceOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_TILE") || !strcmp(type, "TILE")) return ParseDmlTileOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_TOP_K") || !strcmp(type, "TOP_K")) return ParseDmlTopKOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_BATCH_NORMALIZATION") || !strcmp(type, "BATCH_NORMALIZATION")) return ParseDmlBatchNormalizationOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_BATCH_NORMALIZATION_GRAD") || !strcmp(type, "BATCH_NORMALIZATION_GRAD")) return ParseDmlBatchNormalizationGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_BATCH_NORMALIZATION_TRAINING_GRAD") || !strcmp(type, "BATCH_NORMALIZATION_TRAINING_GRAD")) return ParseDmlBatchNormalizationTrainingGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION") || !strcmp(type, "MEAN_VARIANCE_NORMALIZATION")) return ParseDmlMeanVarianceNormalizationOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION") || !strcmp(type, "LOCAL_RESPONSE_NORMALIZATION")) return ParseDmlLocalResponseNormalizationOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION_GRAD") || !strcmp(type, "LOCAL_RESPONSE_NORMALIZATION_GRAD")) return ParseDmlLocalResponseNormalizationGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_LP_NORMALIZATION") || !strcmp(type, "LP_NORMALIZATION")) return ParseDmlLpNormalizationOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_RNN") || !strcmp(type, "RNN")) return ParseDmlRnnOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_LSTM") || !strcmp(type, "LSTM")) return ParseDmlLstmOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_GRU") || !strcmp(type, "GRU")) return ParseDmlGruOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_SIGN") || !strcmp(type, "ELEMENT_WISE_SIGN")) return ParseDmlElementWiseSignOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_IS_NAN") || !strcmp(type, "ELEMENT_WISE_IS_NAN")) return ParseDmlElementWiseIsNanOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_NEGATE") || !strcmp(type, "ELEMENT_WISE_NEGATE")) return ParseDmlElementWiseNegateOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ERF") || !strcmp(type, "ELEMENT_WISE_ERF")) return ParseDmlElementWiseErfOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_SINH") || !strcmp(type, "ELEMENT_WISE_SINH")) return ParseDmlElementWiseSinhOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_COSH") || !strcmp(type, "ELEMENT_WISE_COSH")) return ParseDmlElementWiseCoshOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_TANH") || !strcmp(type, "ELEMENT_WISE_TANH")) return ParseDmlElementWiseTanhOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ASINH") || !strcmp(type, "ELEMENT_WISE_ASINH")) return ParseDmlElementWiseAsinhOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ACOSH") || !strcmp(type, "ELEMENT_WISE_ACOSH")) return ParseDmlElementWiseAcoshOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ATANH") || !strcmp(type, "ELEMENT_WISE_ATANH")) return ParseDmlElementWiseAtanhOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_IF") || !strcmp(type, "ELEMENT_WISE_IF")) return ParseDmlElementWiseIfOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ADD1") || !strcmp(type, "ELEMENT_WISE_ADD1")) return ParseDmlElementWiseAdd1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MAX_UNPOOLING") || !strcmp(type, "MAX_UNPOOLING")) return ParseDmlMaxUnpoolingOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_DIAGONAL_MATRIX") || !strcmp(type, "DIAGONAL_MATRIX")) return ParseDmlDiagonalMatrixOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_SCATTER") || !strcmp(type, "SCATTER")) return ParseDmlScatterOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ONE_HOT") || !strcmp(type, "ONE_HOT")) return ParseDmlOneHotOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_RESAMPLE") || !strcmp(type, "RESAMPLE")) return ParseDmlResampleOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_LEFT") || !strcmp(type, "ELEMENT_WISE_BIT_SHIFT_LEFT")) return ParseDmlElementWiseBitShiftLeftOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_RIGHT") || !strcmp(type, "ELEMENT_WISE_BIT_SHIFT_RIGHT")) return ParseDmlElementWiseBitShiftRightOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_ROUND") || !strcmp(type, "ELEMENT_WISE_ROUND")) return ParseDmlElementWiseRoundOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_IS_INFINITY") || !strcmp(type, "ELEMENT_WISE_IS_INFINITY")) return ParseDmlElementWiseIsInfinityOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_MODULUS_TRUNCATE") || !strcmp(type, "ELEMENT_WISE_MODULUS_TRUNCATE")) return ParseDmlElementWiseModulusTruncateOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_MODULUS_FLOOR") || !strcmp(type, "ELEMENT_WISE_MODULUS_FLOOR")) return ParseDmlElementWiseModulusFloorOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_FILL_VALUE_CONSTANT") || !strcmp(type, "FILL_VALUE_CONSTANT")) return ParseDmlFillValueConstantOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_FILL_VALUE_SEQUENCE") || !strcmp(type, "FILL_VALUE_SEQUENCE")) return ParseDmlFillValueSequenceOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_CUMULATIVE_SUMMATION") || !strcmp(type, "CUMULATIVE_SUMMATION")) return ParseDmlCumulativeSummationOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_CUMULATIVE_PRODUCT") || !strcmp(type, "CUMULATIVE_PRODUCT")) return ParseDmlCumulativeProductOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_REVERSE_SUBSEQUENCES") || !strcmp(type, "REVERSE_SUBSEQUENCES")) return ParseDmlReverseSubsequencesOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_GATHER_ELEMENTS") || !strcmp(type, "GATHER_ELEMENTS")) return ParseDmlGatherElementsOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_GATHER_ND") || !strcmp(type, "GATHER_ND")) return ParseDmlGatherNdOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_SCATTER_ND") || !strcmp(type, "SCATTER_ND")) return ParseDmlScatterNdOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MAX_POOLING2") || !strcmp(type, "MAX_POOLING2")) return ParseDmlMaxPooling2OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_SLICE1") || !strcmp(type, "SLICE1")) return ParseDmlSlice1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_TOP_K1") || !strcmp(type, "TOP_K1")) return ParseDmlTopK1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_DEPTH_TO_SPACE1") || !strcmp(type, "DEPTH_TO_SPACE1")) return ParseDmlDepthToSpace1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_SPACE_TO_DEPTH1") || !strcmp(type, "SPACE_TO_DEPTH1")) return ParseDmlSpaceToDepth1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION1") || !strcmp(type, "MEAN_VARIANCE_NORMALIZATION1")) return ParseDmlMeanVarianceNormalization1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_RESAMPLE1") || !strcmp(type, "RESAMPLE1")) return ParseDmlResample1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MATRIX_MULTIPLY_INTEGER") || !strcmp(type, "MATRIX_MULTIPLY_INTEGER")) return ParseDmlMatrixMultiplyIntegerOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_QUANTIZED_LINEAR_MATRIX_MULTIPLY") || !strcmp(type, "QUANTIZED_LINEAR_MATRIX_MULTIPLY")) return ParseDmlQuantizedLinearMatrixMultiplyOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_CONVOLUTION_INTEGER") || !strcmp(type, "CONVOLUTION_INTEGER")) return ParseDmlConvolutionIntegerOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_QUANTIZED_LINEAR_CONVOLUTION") || !strcmp(type, "QUANTIZED_LINEAR_CONVOLUTION")) return ParseDmlQuantizedLinearConvolutionOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_BIT_AND") || !strcmp(type, "ELEMENT_WISE_BIT_AND")) return ParseDmlElementWiseBitAndOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_BIT_OR") || !strcmp(type, "ELEMENT_WISE_BIT_OR")) return ParseDmlElementWiseBitOrOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_BIT_XOR") || !strcmp(type, "ELEMENT_WISE_BIT_XOR")) return ParseDmlElementWiseBitXorOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_BIT_NOT") || !strcmp(type, "ELEMENT_WISE_BIT_NOT")) return ParseDmlElementWiseBitNotOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_BIT_COUNT") || !strcmp(type, "ELEMENT_WISE_BIT_COUNT")) return ParseDmlElementWiseBitCountOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_RELU_GRAD") || !strcmp(type, "ACTIVATION_RELU_GRAD")) return ParseDmlActivationReluGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_AVERAGE_POOLING_GRAD") || !strcmp(type, "AVERAGE_POOLING_GRAD")) return ParseDmlAveragePoolingGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MAX_POOLING_GRAD") || !strcmp(type, "MAX_POOLING_GRAD")) return ParseDmlMaxPoolingGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_RANDOM_GENERATOR") || !strcmp(type, "RANDOM_GENERATOR")) return ParseDmlRandomGeneratorOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_NONZERO_COORDINATES") || !strcmp(type, "NONZERO_COORDINATES")) return ParseDmlNonzeroCoordinatesOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_RESAMPLE_GRAD") || !strcmp(type, "RESAMPLE_GRAD")) return ParseDmlResampleGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_SLICE_GRAD") || !strcmp(type, "SLICE_GRAD")) return ParseDmlSliceGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ADAM_OPTIMIZER") || !strcmp(type, "ADAM_OPTIMIZER")) return ParseDmlAdamOptimizerOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ROI_ALIGN") || !strcmp(type, "ROI_ALIGN")) return ParseDmlRoiAlignOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ROI_ALIGN1") || !strcmp(type, "ROI_ALIGN1")) return ParseDmlRoiAlign1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_GATHER_ND1") || !strcmp(type, "GATHER_ND1")) return ParseDmlGatherNd1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_DYNAMIC_QUANTIZE_LINEAR") || !strcmp(type, "DYNAMIC_QUANTIZE_LINEAR")) return ParseDmlDynamicQuantizeLinearOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ELEMENT_WISE_QUANTIZED_LINEAR_ADD") || !strcmp(type, "ELEMENT_WISE_QUANTIZED_LINEAR_ADD")) return ParseDmlElementWiseQuantizedLinearAddOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ROI_ALIGN_GRAD") || !strcmp(type, "ROI_ALIGN_GRAD")) return ParseDmlRoiAlignGradOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_BATCH_NORMALIZATION_TRAINING") || !strcmp(type, "BATCH_NORMALIZATION_TRAINING")) return ParseDmlBatchNormalizationTrainingOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_RESAMPLE2") || !strcmp(type, "RESAMPLE2")) return ParseDmlResample2OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_RESAMPLE_GRAD1") || !strcmp(type, "RESAMPLE_GRAD1")) return ParseDmlResampleGrad1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_DIAGONAL_MATRIX1") || !strcmp(type, "DIAGONAL_MATRIX1")) return ParseDmlDiagonalMatrix1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MULTIHEAD_ATTENTION") || !strcmp(type, "MULTIHEAD_ATTENTION")) return ParseDmlMultiheadAttentionOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_QUANTIZED_LINEAR_AVERAGE_POOLING") || !strcmp(type, "QUANTIZED_LINEAR_AVERAGE_POOLING")) return ParseDmlQuantizedLinearAveragePoolingOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_MATRIX_MULTIPLY_INTEGER_TO_FLOAT") || !strcmp(type, "MATRIX_MULTIPLY_INTEGER_TO_FLOAT")) return ParseDmlMatrixMultiplyIntegerToFloatOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_ELU") || !strcmp(type, "ACTIVATION_ELU")) return ParseDmlActivationEluOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_CELU") || !strcmp(type, "ACTIVATION_CELU")) return ParseDmlActivationCeluOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_HARDMAX") || !strcmp(type, "ACTIVATION_HARDMAX")) return ParseDmlActivationHardmaxOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_HARDMAX1") || !strcmp(type, "ACTIVATION_HARDMAX1")) return ParseDmlActivationHardmax1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_HARD_SIGMOID") || !strcmp(type, "ACTIVATION_HARD_SIGMOID")) return ParseDmlActivationHardSigmoidOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_IDENTITY") || !strcmp(type, "ACTIVATION_IDENTITY")) return ParseDmlActivationIdentityOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_LEAKY_RELU") || !strcmp(type, "ACTIVATION_LEAKY_RELU")) return ParseDmlActivationLeakyReluOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_LINEAR") || !strcmp(type, "ACTIVATION_LINEAR")) return ParseDmlActivationLinearOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_LOG_SOFTMAX") || !strcmp(type, "ACTIVATION_LOG_SOFTMAX")) return ParseDmlActivationLogSoftmaxOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_LOG_SOFTMAX1") || !strcmp(type, "ACTIVATION_LOG_SOFTMAX1")) return ParseDmlActivationLogSoftmax1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_PARAMETERIZED_RELU") || !strcmp(type, "ACTIVATION_PARAMETERIZED_RELU")) return ParseDmlActivationParameterizedReluOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_PARAMETRIC_SOFTPLUS") || !strcmp(type, "ACTIVATION_PARAMETRIC_SOFTPLUS")) return ParseDmlActivationParametricSoftplusOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_RELU") || !strcmp(type, "ACTIVATION_RELU")) return ParseDmlActivationReluOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_SCALED_ELU") || !strcmp(type, "ACTIVATION_SCALED_ELU")) return ParseDmlActivationScaledEluOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_SCALED_TANH") || !strcmp(type, "ACTIVATION_SCALED_TANH")) return ParseDmlActivationScaledTanhOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_SIGMOID") || !strcmp(type, "ACTIVATION_SIGMOID")) return ParseDmlActivationSigmoidOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_SOFTMAX") || !strcmp(type, "ACTIVATION_SOFTMAX")) return ParseDmlActivationSoftmaxOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_SOFTMAX1") || !strcmp(type, "ACTIVATION_SOFTMAX1")) return ParseDmlActivationSoftmax1OperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_SOFTPLUS") || !strcmp(type, "ACTIVATION_SOFTPLUS")) return ParseDmlActivationSoftplusOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_SOFTSIGN") || !strcmp(type, "ACTIVATION_SOFTSIGN")) return ParseDmlActivationSoftsignOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_TANH") || !strcmp(type, "ACTIVATION_TANH")) return ParseDmlActivationTanhOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_THRESHOLDED_RELU") || !strcmp(type, "ACTIVATION_THRESHOLDED_RELU")) return ParseDmlActivationThresholdedReluOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_SHRINK") || !strcmp(type, "ACTIVATION_SHRINK")) return ParseDmlActivationShrinkOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_GELU") || !strcmp(type, "ACTIVATION_GELU")) return ParseDmlActivationGeluOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_SWISH") || !strcmp(type, "ACTIVATION_SWISH")) return ParseDmlActivationSwishOperatorDesc(descValue, fused, allocator);
    if (!strcmp(type, "DML_OPERATOR_ACTIVATION_HARD_SWISH") || !strcmp(type, "ACTIVATION_HARD_SWISH")) return ParseDmlActivationHardSwishOperatorDesc(descValue, fused, allocator);
    throw std::invalid_argument("Unknown operator type.");
}

Model::DmlDispatchableDesc::BindPoints GetBindPoints(const DML_OPERATOR_DESC& desc)
{
    switch (desc.Type)
    {
    case DML_OPERATOR_ELEMENT_WISE_IDENTITY: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ABS: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ABS_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ACOS: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ACOS_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ADD: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ADD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ASIN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ASIN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ATAN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ATAN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_CEIL: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_CEIL_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_CLIP: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_CLIP_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_CLIP1: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_CLIP1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD1: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_CLIP_GRAD1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_COS: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_COS_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_DIVIDE: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_EXP: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_EXP_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_FLOOR: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_FLOOR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOG: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOG_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOGICAL_AND: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOGICAL_EQUALS: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOGICAL_NOT: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOGICAL_OR: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_LOGICAL_XOR: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_MAX: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_MAX_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_MEAN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_MEAN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_MIN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_MIN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_MULTIPLY: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_POW: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_POW_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_CONSTANT_POW: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_RECIP: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_RECIP_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_SIN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_SIN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_SQRT: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_SQRT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_DIFFERENCE_SQUARE: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ATAN_YX: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_SUBTRACT: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_TAN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_TAN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_THRESHOLD: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_QUANTIZE_LINEAR: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_DEQUANTIZE_LINEAR: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_CONVOLUTION: return GetBindPoints(*reinterpret_cast<const DML_CONVOLUTION_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_GEMM: return GetBindPoints(*reinterpret_cast<const DML_GEMM_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_REDUCE: return GetBindPoints(*reinterpret_cast<const DML_REDUCE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ARGMIN: return GetBindPoints(*reinterpret_cast<const DML_ARGMIN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ARGMAX: return GetBindPoints(*reinterpret_cast<const DML_ARGMAX_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_AVERAGE_POOLING: return GetBindPoints(*reinterpret_cast<const DML_AVERAGE_POOLING_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_AVERAGE_POOLING1: return GetBindPoints(*reinterpret_cast<const DML_AVERAGE_POOLING1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_LP_POOLING: return GetBindPoints(*reinterpret_cast<const DML_LP_POOLING_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_LP_POOLING1: return GetBindPoints(*reinterpret_cast<const DML_LP_POOLING1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MAX_POOLING: return GetBindPoints(*reinterpret_cast<const DML_MAX_POOLING_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MAX_POOLING1: return GetBindPoints(*reinterpret_cast<const DML_MAX_POOLING1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ROI_POOLING: return GetBindPoints(*reinterpret_cast<const DML_ROI_POOLING_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_SLICE: return GetBindPoints(*reinterpret_cast<const DML_SLICE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_CAST: return GetBindPoints(*reinterpret_cast<const DML_CAST_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_SPLIT: return GetBindPoints(*reinterpret_cast<const DML_SPLIT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_JOIN: return GetBindPoints(*reinterpret_cast<const DML_JOIN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_PADDING: return GetBindPoints(*reinterpret_cast<const DML_PADDING_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_PADDING1: return GetBindPoints(*reinterpret_cast<const DML_PADDING1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_VALUE_SCALE_2D: return GetBindPoints(*reinterpret_cast<const DML_VALUE_SCALE_2D_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_UPSAMPLE_2D: return GetBindPoints(*reinterpret_cast<const DML_UPSAMPLE_2D_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_GATHER: return GetBindPoints(*reinterpret_cast<const DML_GATHER_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_SPACE_TO_DEPTH: return GetBindPoints(*reinterpret_cast<const DML_SPACE_TO_DEPTH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_DEPTH_TO_SPACE: return GetBindPoints(*reinterpret_cast<const DML_DEPTH_TO_SPACE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_TILE: return GetBindPoints(*reinterpret_cast<const DML_TILE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_TOP_K: return GetBindPoints(*reinterpret_cast<const DML_TOP_K_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_BATCH_NORMALIZATION: return GetBindPoints(*reinterpret_cast<const DML_BATCH_NORMALIZATION_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_BATCH_NORMALIZATION_GRAD: return GetBindPoints(*reinterpret_cast<const DML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_BATCH_NORMALIZATION_TRAINING_GRAD: return GetBindPoints(*reinterpret_cast<const DML_BATCH_NORMALIZATION_TRAINING_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION: return GetBindPoints(*reinterpret_cast<const DML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION: return GetBindPoints(*reinterpret_cast<const DML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION_GRAD: return GetBindPoints(*reinterpret_cast<const DML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_LP_NORMALIZATION: return GetBindPoints(*reinterpret_cast<const DML_LP_NORMALIZATION_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_RNN: return GetBindPoints(*reinterpret_cast<const DML_RNN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_LSTM: return GetBindPoints(*reinterpret_cast<const DML_LSTM_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_GRU: return GetBindPoints(*reinterpret_cast<const DML_GRU_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_SIGN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_SIGN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_IS_NAN: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_IS_NAN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_NEGATE: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_NEGATE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ERF: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ERF_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_SINH: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_SINH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_COSH: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_COSH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_TANH: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_TANH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ASINH: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ASINH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ACOSH: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ACOSH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ATANH: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ATANH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_IF: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_IF_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ADD1: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ADD1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MAX_UNPOOLING: return GetBindPoints(*reinterpret_cast<const DML_MAX_UNPOOLING_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_DIAGONAL_MATRIX: return GetBindPoints(*reinterpret_cast<const DML_DIAGONAL_MATRIX_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_SCATTER: return GetBindPoints(*reinterpret_cast<const DML_SCATTER_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ONE_HOT: return GetBindPoints(*reinterpret_cast<const DML_ONE_HOT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_RESAMPLE: return GetBindPoints(*reinterpret_cast<const DML_RESAMPLE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_LEFT: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_RIGHT: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_ROUND: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_ROUND_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_IS_INFINITY: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_MODULUS_TRUNCATE: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_MODULUS_FLOOR: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_FILL_VALUE_CONSTANT: return GetBindPoints(*reinterpret_cast<const DML_FILL_VALUE_CONSTANT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_FILL_VALUE_SEQUENCE: return GetBindPoints(*reinterpret_cast<const DML_FILL_VALUE_SEQUENCE_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_CUMULATIVE_SUMMATION: return GetBindPoints(*reinterpret_cast<const DML_CUMULATIVE_SUMMATION_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_CUMULATIVE_PRODUCT: return GetBindPoints(*reinterpret_cast<const DML_CUMULATIVE_PRODUCT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_REVERSE_SUBSEQUENCES: return GetBindPoints(*reinterpret_cast<const DML_REVERSE_SUBSEQUENCES_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_GATHER_ELEMENTS: return GetBindPoints(*reinterpret_cast<const DML_GATHER_ELEMENTS_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_GATHER_ND: return GetBindPoints(*reinterpret_cast<const DML_GATHER_ND_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_SCATTER_ND: return GetBindPoints(*reinterpret_cast<const DML_SCATTER_ND_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MAX_POOLING2: return GetBindPoints(*reinterpret_cast<const DML_MAX_POOLING2_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_SLICE1: return GetBindPoints(*reinterpret_cast<const DML_SLICE1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_TOP_K1: return GetBindPoints(*reinterpret_cast<const DML_TOP_K1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_DEPTH_TO_SPACE1: return GetBindPoints(*reinterpret_cast<const DML_DEPTH_TO_SPACE1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_SPACE_TO_DEPTH1: return GetBindPoints(*reinterpret_cast<const DML_SPACE_TO_DEPTH1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION1: return GetBindPoints(*reinterpret_cast<const DML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_RESAMPLE1: return GetBindPoints(*reinterpret_cast<const DML_RESAMPLE1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MATRIX_MULTIPLY_INTEGER: return GetBindPoints(*reinterpret_cast<const DML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_QUANTIZED_LINEAR_MATRIX_MULTIPLY: return GetBindPoints(*reinterpret_cast<const DML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_CONVOLUTION_INTEGER: return GetBindPoints(*reinterpret_cast<const DML_CONVOLUTION_INTEGER_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_QUANTIZED_LINEAR_CONVOLUTION: return GetBindPoints(*reinterpret_cast<const DML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_BIT_AND: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_BIT_AND_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_BIT_OR: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_BIT_OR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_BIT_XOR: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_BIT_NOT: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_BIT_COUNT: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_RELU_GRAD: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_RELU_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_AVERAGE_POOLING_GRAD: return GetBindPoints(*reinterpret_cast<const DML_AVERAGE_POOLING_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MAX_POOLING_GRAD: return GetBindPoints(*reinterpret_cast<const DML_MAX_POOLING_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_RANDOM_GENERATOR: return GetBindPoints(*reinterpret_cast<const DML_RANDOM_GENERATOR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_NONZERO_COORDINATES: return GetBindPoints(*reinterpret_cast<const DML_NONZERO_COORDINATES_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_RESAMPLE_GRAD: return GetBindPoints(*reinterpret_cast<const DML_RESAMPLE_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_SLICE_GRAD: return GetBindPoints(*reinterpret_cast<const DML_SLICE_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ADAM_OPTIMIZER: return GetBindPoints(*reinterpret_cast<const DML_ADAM_OPTIMIZER_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ROI_ALIGN: return GetBindPoints(*reinterpret_cast<const DML_ROI_ALIGN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ROI_ALIGN1: return GetBindPoints(*reinterpret_cast<const DML_ROI_ALIGN1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_GATHER_ND1: return GetBindPoints(*reinterpret_cast<const DML_GATHER_ND1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_DYNAMIC_QUANTIZE_LINEAR: return GetBindPoints(*reinterpret_cast<const DML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ELEMENT_WISE_QUANTIZED_LINEAR_ADD: return GetBindPoints(*reinterpret_cast<const DML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ROI_ALIGN_GRAD: return GetBindPoints(*reinterpret_cast<const DML_ROI_ALIGN_GRAD_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_BATCH_NORMALIZATION_TRAINING: return GetBindPoints(*reinterpret_cast<const DML_BATCH_NORMALIZATION_TRAINING_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_RESAMPLE2: return GetBindPoints(*reinterpret_cast<const DML_RESAMPLE2_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_RESAMPLE_GRAD1: return GetBindPoints(*reinterpret_cast<const DML_RESAMPLE_GRAD1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_DIAGONAL_MATRIX1: return GetBindPoints(*reinterpret_cast<const DML_DIAGONAL_MATRIX1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MULTIHEAD_ATTENTION: return GetBindPoints(*reinterpret_cast<const DML_MULTIHEAD_ATTENTION_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_QUANTIZED_LINEAR_AVERAGE_POOLING: return GetBindPoints(*reinterpret_cast<const DML_QUANTIZED_LINEAR_AVERAGE_POOLING_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_MATRIX_MULTIPLY_INTEGER_TO_FLOAT: return GetBindPoints(*reinterpret_cast<const DML_MATRIX_MULTIPLY_INTEGER_TO_FLOAT_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_ELU: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_ELU_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_CELU: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_CELU_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_HARDMAX: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_HARDMAX_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_HARDMAX1: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_HARDMAX1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_HARD_SIGMOID: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_IDENTITY: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_IDENTITY_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_LEAKY_RELU: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_LINEAR: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_LINEAR_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_LOG_SOFTMAX: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_LOG_SOFTMAX1: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_LOG_SOFTMAX1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_PARAMETERIZED_RELU: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_PARAMETRIC_SOFTPLUS: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_RELU: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_RELU_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_SCALED_ELU: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_SCALED_ELU_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_SCALED_TANH: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_SCALED_TANH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_SIGMOID: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_SIGMOID_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_SOFTMAX: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_SOFTMAX_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_SOFTMAX1: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_SOFTMAX1_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_SOFTPLUS: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_SOFTPLUS_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_SOFTSIGN: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_SOFTSIGN_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_TANH: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_TANH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_THRESHOLDED_RELU: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_SHRINK: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_SHRINK_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_GELU: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_GELU_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_SWISH: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_SWISH_OPERATOR_DESC*>(desc.Desc));
    case DML_OPERATOR_ACTIVATION_HARD_SWISH: return GetBindPoints(*reinterpret_cast<const DML_ACTIVATION_HARD_SWISH_OPERATOR_DESC*>(desc.Desc));
    default: throw std::invalid_argument("Unknown operator type.");
    }
}
